# $0000-$00FF

## 0 $00 D8502 <a name="00"></a>
### Data direction register for processor's on-chip I/O port
Bits 0-6 in this location control the direction of data flow for
the seven I/O (input/output) lines on the 8502 microprocessor
chip, labeled P0-P6. Setting a bit to %0 makes the corresponding line
an input, and its state can be read at the corresponding bit position
in location $01. Setting a bit to %1 makes the
corresponding line an output, and its state will be controlled
by the setting of the corresponding bit position in location
$01. The value here is initialized to 47/$2F by the IOINIT
routine [$E109], part of both the reset and RUN/STOP-RESTORE
sequences. This sets lines 0-3 and 5 for output and
lines 4 and 6 for input. Since only seven lines are provided,
bit 7 is not used. That bit will retain whatever value is written
to it, but its setting has no effect.

## 1 $01 R8502 <a name="01"></a>
### Data register for processor's on-chip I/O port
Each of the seven I/O lines on the 8502 microprocessor has a
corresponding bit in this location (bit 7 is unused). The direction
of data flow on the lines is controlled by location $00. If
an I/O port line is set for input, the corresponding bit here
will reflect the state of the input line: %0 if the line is low (0
volts), or %1 if the line is high (+5 volts). While a line is set
for input, values written to the corresponding bit have no effect.
If an I/O port line is set for output, its state will be controlled
by the corresponding bit in this location. Storing a %0
in the bit forces the output line to a low (0 volts) state, while
storing a %1 in the bit sets the line to a high (+5v state).
The I/O lines are connected as follows.

**Bits 0-1**: the lines connected to these bits control which of the
two 1K blocks of color memory will be visible at 55296-56319/
$D800-$DBFF when the I/O block is selected. For this purpose, the
lines should always be configured as outputs. Unlike
in the Commodore 64, these bits have no effect on whether
RAM or ROM is selected at a given address. In the 128, memory
management is the domain of the MMU chip. 
Bit 0 controls which block the processor sees, while bit 1
controls which block the VIC chip sees. Setting either bit to
%0 selects block 0, while a setting of %1 selects block 1. The
setting of these bits is established during the screen-setup
portion of the screen IRQ routine [$C194], That routine sets both
bits to %1 for text mode (GRAPHIC 0), or for the text portion
of the split-screen modes (GRAPHIC 2 or GRAPHIC 4). For
the bitmapped modes (GRAPHIC 1 or GRAPHIC 3) or for the
bitmapped portion of the split-screen modes, bit 1 is set to
%0. Thus, the VIC sees different blocks of memory for the
modes, and drawing on the bitmapped screen will not disturb
colors on the text screen. To manipulate these bits in other
ways, the screen-setup portion of the IRQ routine must be disabled.

**Bit 2**: the line for this bit, known as the CHAREN line, determines
whether the VIC chip will see character ROM in its current video bank.
For proper functioning, the line should be
configured as an output. While this bit is %0, the VIC chip
will see character ROM beginning at an offset of 4096/$1000
from the start of the bank. The uppercase/graphics set will
appear to occupy locations with offsets of 4096-6143/
$1000-$17FF, and the lowercase/uppercase set will appear at
offsets of 6144-8191/$1800-$lFFF. The character sets will be
visible in all VIC video banks, not just banks 0 and 2 as was
the case in the Commodore 64. Only the VIC chip will see the
character ROM at these addresses; the processor will still see
the locations as RAM or system ROM, depending on the address and
bank configuration.
To disable this feature and allow the VIC chip to see
RAM at the character set image addresses, the CHAREN bit
must be set to %1. However, this cannot normally be done directly
because this bit has a shadow at location [217/$D9](#D9). During the text
mode-setup portion of the screen editor IRQ
routine [$C194], the value of bit 2 of the shadow location is
copied into this bit. Thus, to change this bit you should set bit
2 of the shadow location instead. If the screen-setup portion of
the IRQ routine is disabled (by storing the value 255/$FF in
location [216/$D8](#D8), for example), the setting of this bit can then
be changed directly. The IRQ routine always sets this bit to
%1 for bitmapped screen modes or for the bitmapped portion
of split-screen modes.

**Bit 3**: the line for this bit is connected to the CASS WRT
(cassette write) line of the cassette port. The setting of this bit
determines whether a signal is being written to the tape. For this
purpose, the line must be configured as an output. 

**Bit 4**: the line for this bit is connected to the CASS SENSE
(cassette button sense) line of the cassette port. If the port line
is configured as an input, this bit can be read to determine
whether any buttons are currently pressed on the Datassette.
When no buttons are pressed (or when no Datassette is connected to the port),
this bit will be %1. Pressing any button
will change this bit to %0. Unfortunately, the bit merely detects whether
buttons are pressed, and cannot indicate which
specific buttons. If you press FAST FORWARD when instructed to press PLAY,
the 128 won't notice the difference.

**Bit 5**: the line for this bit controls the CASS MTR (cassette
motor) line of the cassette port. When this bit is %1 , the
power supply to the cassette motor, provided via the CASS
MTR line, is turned off. Setting this bit to %0 turns on the 9-
volt power supply to the motor. The setting of this bit is controlled by
a shadow location, the cassette motor interlock at
[192/$C0](#C0).

**Bit 6**: the line for this bit is connected to the CAPS LOCK key
on the keyboard. The line should be configured as an input to
read the state of this key. The bit will return a %1 while the
key is in the up position (CAPS LOCK off), and a %0 when
the key is down (CAPS LOCK on). The status of this bit is
read by the SCNKEY routine [$C55D] during each system
IRQ, and bit 4 of location [211/$D3](#D3) will be assigned the opposite
setting of this bit.

**Bit 7**: there is no I/O port line connected to this bit, so the
value here is meaningless. The bit always returns a %0 when
read.

## 2 $02 BANK <a name="02"></a>
### Data register for processor's on-chip I/O port
The value here determines the bank to which the JMPFAR
routine [S02E3] will jump. Because the JSRFAR routine
[$02CD] calls JMPFAR as a subroutine, the value here also determines
the destination bank for a JSRFAR. This location
should be loaded with the number (0-15) of the desired bank
before either JMPFAR or JSRFAR is used.
The BASIC SYS statement is implemented using JSRFAR.
In that case, the value here is set from the value in location
981/$03D5, which holds the parameter from the most recent
BANK statement (15/$0F by default). The BASIC routine that
searches for a token in the runtime stack [$4FAA] also uses
location 2/$02 for temporary storage.

When the monitor is entered at the break entry point
[$B003], this location is loaded with the bank number in
which the system was operating when the BRK opcode was
encountered. When the monitor is entered at the cold-start entry point
[$B000], as by the BASIC MONITOR command, this
location is initialized to 15/$0F (for bank 15). The monitor R
command displays the value in this location as the first hexadecimal
digit of the PC value. The register change (;) command can be used
to alter the value stored here. The value
determines the bank for the monitor G (go to routine) and J
(jump to subroutine) commands, which use JMPFAR and
JSRFAR, respectively.

## 3-4 $03-04 PC <a name="03"></a><a name="04"></a>
### Target address for JMPFAR and JSRFAR
The values here determine the address to which the JMPFAR
routine [$02E3] will jump. Because the JSRFAR routine
[$02CD] calls JMPFAR as a subroutine, the value here also determines
the destination address for a JSRFAR. These locations
should be loaded with the desired address before either
JMPFAR or JSRFAR is used. Contrary to the normal order of
address bytes, the high byte of the target address should be
stored in location 3/$03 and the low byte in location 4/$04.
When the monitor is entered at the break entry point
[$3003], these locations are loaded with the program counter
contents stored on the stack when the BRK opcode was encountered.

Because of the way the microprocessor handles
BRK, this value will be two bytes beyond the address of the
BRK ($00) opcode. When the monitor is entered at the coldstart entry point
[$B000], as by the BASIC MONITOR command, these locations are initialized to
45056/$B000 (the coldstart entry address). The monitor R command displays the
value in these locations as the four rightmost hexadecimal digits of the PC value.
The register change (;) command can be
used to alter the value stored here. The value determines the
target address for the monitor G (go to routine) and J (jump to
subroutine) commands, which use JMPFAR and JSRFAR,
respectively.

## 5 $05 S-REG <a name="05"></a>
### Status register storage for JMPFAR and JSRFAR
The value in this location is transferred to the processor's status
register when a routine is called with JMPFAR [$02E3]. Because JSRFAR
[$02CD] also uses JMPFAR, the value here will
also determine the initial status register value for a routine
called with JSRFAR. You can use this location to set up particular entry
conditions for the target routine. For example,
certain system routines behave differently depending on
whether the carry bit, bit 0 of the status register, is clear (%0)
or set (%1) when the routine is called. You can specify the entry setting
of the carry bit by setting bit 0 of this location. Next figure shows the
function of the various status register bits. If
you don't need any special entry conditions, it's best to set
this location to [0/$00](#00).

The contents of the status register upon return from the
target routine are stored in this location before return from
JSRFAR, so you can read this location to determine the exit
status of the routine. This is useful because system routines
often use status register bits, particularly carry, to return information
about the success of the operation performed by the
routine.

![Processor Status Register](resources/002-01-f-processor-status-register.png)

The BASIC 7.0 version of the SYS statement allows you
to specify a status register value, which will be placed in this
location before the JSRFAR to the specified address. The
RREG statement can be used to read the value here. The status register
value returned by RREG is actually the contents of
this location.

When the monitor is entered at the break entry point
[$B003], this location is loaded with the status register contents
stored on the stack when the BRK opcode was encountered.
When the monitor is entered at the cold-start entry point
[$B000], as by the BASIC MONITOR command, this location
is initialized to zero. The monitor R command displays the
value in this location under the heading SR. The register
change (;) command can be used to alter the value stored here.
The value determines the status register contents for the monitor G
(go to routine) and J (jump to subroutine) commands,
which use JMPFAR and JSRFAR, respectively.

## 6 $06 A_REG <a name="06"></a>
### Accumulator storage for JMPFAR and JSRFAR
The value in this location is transferred to the processor's
accumulator (A register) when a routine is called with JMPFAR
[$02E3]. Because JSRFAR [$02CD] also uses JMPFAR, the
value here will also determine the initial accumulator value for
a routine called with JSRFAR. You can use this location to set
up a particular entry value for the target routine. The contents
of the accumulator upon return from the target routine are
stored in this location before return from JSRFAR, so you can
read this location to determine the exit accumulator value. The
JSRFAR routine itself uses the accumulator after return from
the target routine, so you must look to this location for the
accumulator value from the target routine.
The BASIC 7.0 version of the SYS statement allows you
to specify an accumulator value, which will be placed in this
location before the JSRFAR to the specified address. The
RREG statement can be used to read the value here.
The accumulator value returned by RREG is actually the contents of
this location.

When the monitor is entered at the break entry point
[$B003], this location is loaded with the accumulator contents
stored on the stack by the IRQ/BRK handler [$FF17]. When
the monitor is entered at the cold-start entry point [$B000], as
by the BASIC MONITOR command, this location is initialized
to zero. The monitor R command displays the value in this location
under the heading AC. The register change (;) command can be used to
alter the value stored here. The value
determines the accumulator contents for the monitor G (go to
routine) and J (jump to subroutine) commands, which use
JMPFAR and JSRFAR, respectively.

## 7 $07 X_REG <a name="07"></a>
### X register storage for JMPFAR and JSRFAR
The value in this location is transferred to the processor's X
register when a routine is called with JMPFAR [S02E3J. Because JSRFAR
[$02CD] also uses JMPFAR, the value here will
also determine the initial X register value for a routine called
with JSRFAR, You can use this location to set up a particular
entry value for the target routine. The contents of the X register
upon return from the target routine are stored in this location before
return from JSRFAR, so you can read this location to determine the exit
X register value. The JSRFAR routine itself uses the X register after
return from the target routine, so
you must look to this location for the X register value from the
target routine.
The BASIC 7.0 version of the SYS statement allows you
to specify an X register value, which will be placed in this location
before the JSRFAR to the specified address. The RREG
statement can be used to read the value here. The X register
value returned by RREG is actually the contents of this
location.

When the monitor is entered at the break entry point
[$B003], this location is loaded with the X register contents
stored on the stack by the IRQ/BRK handler [$FF17]. When
the monitor is entered at the cold-start entry point [$B000], as
by the BASIC MONITOR command, this location is initialized
to zero. The monitor R command displays the value in this location under
the heading XR. The register change (;) command
can be used to alter the value stored here. The value determines the X
register contents for the monitor G (go to routine)
and J (jump to subroutine) commands, which use JMPFAR and
JSRFAR, respectively.

## 8 $08 Y_REG <a name="08"></a>
### Y register storage for JMPFAR and JSRFAR
The value in this location is transferred to the processor's Y
register when a routine is called with JMPFAR [$02E3]. Because
JSRFAR [$02CD] also uses JMPFAR, the value here will
also determine the initial Y register value for a routine called
with JSRFAR. You can use this location to set up a particular
entry value for the target routine. The contents of the Y register
upon return from the target routine are stored in this location before
return from JSRFAR, so you can read this location
to determine the exit Y register value.
The BASIC 7.0 version of the SYS statement allows you
to specify a Y register value, which will be placed in this location
before the JSRFAR to the specified address. The RREG
statement can be used to read the value here. The Y register
value returned by RREG is actually the contents of this
location.

When the monitor is entered at the break entry point
[$B003], this location is loaded with the Y register contents
stored on the stack by the IRQ/BRK handler [$FF17]. When
the monitor is entered at the cold-start entry point [$B000], as
by the BASIC MONITOR command, this location is initialized
to zero. The monitor R command displays the value in this location
under the heading YR. The register change (;) command
can be used to alter the value stored here. The value determines the
Y register contents for the monitor G (go to routine)
and J (jump to subroutine) commands, which use JMPFAR and
JSRFAR, respectively.

## 9 $09 STKPTR <a name="09"></a>
### Stack pointer storage for JSRFAR and monitor
This location is used in the JSRFAR routine [$02CD] to record
the value in the stack pointer upon return from the target routine.
The value here doesn't affect the setting of the stack
pointer; it merely records the exit value.
When the monitor is entered via either the cold-start entry
point [$B000] or the break entry point [$B003], the current
stack pointer value is stored in this location. The monitor R
command displays the value in this location under the heading SP.

The register change (;) command can be used to alter
the value stored here. The value here is restored to the
microprocessor's stack pointer before the JMPFAR in the G (go
to routine) command routine. This location will hold the stack
pointer value after a J (jump to subroutine) command, since
that routine uses JSRFAR.

## 9 $09 CHARAC or INTEGR
### Working storage for various routines
This location is used for several different purposes by a variety
of BASIC routines. It serves as temporary storage in the routine which
interprets ASCII characters as numeric values
[$50A0]. It holds the value of the desired search character in
the routine which searches for a particular character in a
BASIC program line [$52A2], and in the routine that puts a
string into the string pool [$869A]. It holds the low byte of the
integer value generated in the BASIC INT routine [$8CFB]. It
is also used for temporary storage of intermediate values while
performing BASIC AND or OR operations [$4C86],

## 10 $0A GRAPHM <a name="0A"></a>
### Working storage for various routines
This location is used for several different purposes by a variety
of BASIC routines. It serves as a counter of the number of digits in
the ASCII representation of a number during the routine
which interprets the characters as a numeric value [$50A0]. It
holds the value of the character which terminates the search in
the routine which looks for a particular character in a BASIC
program line [$52A2], and in the one that puts a string into
the string pool [$869A]. It is also used for temporary storage of
intermediate values while performing BASIC AND or OR operations [$4C86].

## 11 $0B TRMPOS <a name="0B"></a>
### Current screen column for TAB and SPC calculations
The value in this location is used during the portion of the
BASIC PRINT routine [$5554] that handles the TAB and SPC
functions. In the computation of the target column for the TAB
or SPC, this location will hold the current cursor column
value.

## 12 $0C VERCK <a name="0C"></a>
### BASIC LOAD/VERIFY flag
The same routine is used to perform both the load and verify
operations, so this flag indicates which is being performed, A
zero value here indicates a load operation, and a nonzero
value indicates verify. The value here is set during the
LOAD/VERIFY [$9129] and DLOAD/DVERIFY [$A1A4]
routines. Both operations use the Kernal LOAD routine
[$F265], which has its own load/verify flag at location
[147/$93](#93).

## 13 $0D COUNT <a name="0D"></a>
### Working storage for various routines
This location is used for different purposes by several BASIC
routines. It holds the most recently found token during program
tokenization [$430A]. In the routine that adds or deletes
BASIC program lines [$4DE2], this location holds the length of
the current line. It is also used as a counter in the RREG routine
[$50BD], and as a counter in the subroutines that find or
create array-variable elements.

## 14 $0E DIMFLG <a name="0E"></a>
### Array dimension flag
This location is used during the routines that create array variables
to indicate whether the routines are being called to as
the result of a DIM statement. For a DIM statement, this location
will contain a nonzero value; otherwise it will be set to
0/$00. This flag is used in testing for the REDIM'D ARRAY
ERROR condition.

## 15 $0F DIMFLG <a name="0F"></a>
### Variable type flag
This location is used to indicate the type of variable currently
being evaluated. A value of 0/$00 indicates that the variable
is numeric. A nonzero value indicates that the variable is
string type. During the routine that finds or creates a variable
[$7AAF], this location is set to 0/$00 if the variable is numeric
type, or to 255/$FF if it is string type.

## 16 $10 INTFLG <a name="10"></a>
### Numeric variable type flag
If the variable currently being evaluated is numeric (see the
entry for location 15/$0F above), bit 7 of this location will be
used to indicate the numeric type. If that bit is %0, the variable
is standard (floating point) type. If the bit is %1, the variable
is integer type. During the routine that finds or creates a
variable [$7AAF], this location will be set to 0/$00 for floating
point variables or 128/$80 for integer variables.

## 17 $11 GARBFL <a name="11"></a>
### Working storage for various routines
This location is used for different purposes in several BASIC
routines. During string evaluation, it is used as a garbage
collection flag. A zero value indicates that no garbage collection has
been performed, while a nonzero value (1/$01)
indicates that garbage collection has taken place. The location
is also used as a quote mode flag during LIST; a value of
0/$00 indicates that quote mode is off, while a nonzero value
(1/$01) indicates that quote mode is in effect. In addition, this
location is used as temporary storage for the high byte of the
disk status variable during the evaluation of the reserved variable DS.

## 18 $12 SUBFLG <a name="12"></a>
### Integer/subscript prohibit flag
This location is used during the routine to find or create a
variable [$7AAF] to specify whether integer or subscripted (array)
variables are allowed. While the value here is zero, the
variable being evaluated can be of any type. The FOR and
DEF routines store the value 128/$80 here. For FOR, this prevents the
use of integer or array variables as loop indexes. For
DEF, this restricts the function definition to floating point variables
and also prevents the parentheses in the function definition from being
interpreted as indicating an array variable.
This location is reset to zero after each variable is evaluated,
and also during CLR [$51F8].

## 19 $13 INPFLG <a name="13"></a>
### Input source flag
BASIC uses a common input handling routine [$56B2] for
READ, GET (including GETKEY and GET#), and INPUT (including INPUT#).
This location is used to indicate which operation is being performed.
The value here will be 152/$98 for a
READ operation, 64/$40 for a GET, or 0/$00 for an INPUT.

## 20 $14 TANSGN <a name="14"></a>
### Comparison type flag - Tangent sign flag
The value in this location is used during the string and number
comparison routine [$4CB6] to specify the type of comparison being
performed, A value here of 1 indicates greater than
(>), 2 indicates equal ( —), and 4 indicates less than (<). The
values are cumulative, so a test for greater than or equal (> —)
would result in a value here of 3 (1 + 2). This location is also
used during the TAN function routine [$9459] to indicate the
sign of the resulting value.

## 21 $15 TANSGN <a name="15"></a>
### Logical file number for BASIC input and output
The value in this location specifies the logical file from which
BASIC will receive input and to which BASIC will direct output.
The default value is 0/$00, which indicates input from
the keyboard and output to the screen. Logical file 0 is reserved
for the system's use; you cannot open logical file 0.
Statements which get input or send output to other devices,
such as GET#, INPUT#, and PRINT*, will temporarily change
the value here to the channel number specified in the statement.
The CMD statement can also be used to change the value
here and direct all output to a specified logical file. However,
you can't depend on CMD (or POKEing a value here) to keep
all output flowing to the specified logical file. A number of
other BASIC statements reset the value here to 0/$00 each
time they are executed, restoring default input and output devices.
These statements include GET (and GET# and GETKEY),
INPUT#, and PRINT*.

## 22-23 $16-17 LINNUM <a name="16"></a><a name="17"></a>
### Integer value of ASCII digit string
These are very busy locations, since the routine which reads
ASCII characters from program text and converts the result to
a two-byte line number value [$50A0] stores its results here.
Other routines which manipulate program lines, such as the
one which adds or deletes program lines, will use these locations to
hold the line number. Any statement which reads a
line number, including GOTO, GOSUB, LIST, and so on, will
expect to find the target line number in these locations. The
TRAP destination line number is held here during the ERROR
routine [$4D3C], and the COLLISION target line number is
held here during the GONE routine [$4A9F].
Machine language programmers can store line number
values in these locations, then jump into a BASIC routine at a
point beyond the line number evaluation step. For example, a
machine language program can enter a BASIC program at any
line number by jumping into the GOTO routine with the target line
number in these locations. The following section of
code performs the equivalent of GOTO 100:

``` Assembly
LDA #$64  // Place line number in $16-$17.
STA $16
LDA #$00
STA $17
LDA #$0F  // Bank number for BASIC ROM (15).
STA $02
LDA #$59  // Enter GOTO routine at $59FB.
STA $03
LDA #$FB
STA $04
JMP $02E3 // Use JMPFAR to call routine
```

## 24 $18 TEMPPT <a name="18"></a>
### Pointer into temporary string descriptor stack
The value in this location points to the next available slot in
the temporary string descriptor stack at 27-35/$1B-$23. This
location can have the following values:

|Value|Meaning|
|-|-|
|27/$1B|no entries (stack empty)|
|30/$1E|one entry|
|33/$21|two entries|
|36/$24|three entries (stack full)|

## 25-26 $19-1A LINNUM <a name="19"></a><a name="1A"></a>
### Pointer to most recent descriptor stack entry
These locations hold the address of the most recent entry in
the temporary string descriptor stack at 27-35/$lB-$23. Location 25/$19
will hold the equivalent of the value in 24/$18
less three, and location 26/$lA will hold zero (it is assigned
this value during the BASIC cold-start sequence). For example,
when there are two entries on the stack, 24/$18 will hold $21,
while these two locations will hold $1E and $00, corresponding to
address $001E, the address of the second entry in the stack.

## 27-35 $1B-23 LINNUM <a name="1B"></a><a name="23"></a>
### Temporary string descriptor stack
The three 3-byte entries here hold descriptors (length plus a 2-
byte pointer to the starting address of the string in the string
pool) for strings being evaluated or assembled. For strings being
assigned to variables, the descriptor value generated here
will be transferred to the variable table entry for that string.








TBC

## 216 $D8 GRAPHM <a name="D8"></a>
### Target bank for JMPFAR and JSRFAR

This location is used during the screen IRQ routine [$C194] to
determine which display mode is selected for the 40-column
(VIC) screen. The value here has no effect on the 80-column
(VDC) screen. When this location contains 0/$00, text mode is
selected. Bits 5-7 control the graphics mode configurations:

|Bit|Bit value|Mode selected|
|-|-|-|
|5|32/$20  | bitmapped|
|6|64/$40  | split bitmapped/text|
|7|128/$80 | multicolor|

More than one of these can be selected at one time. The standard
graphics modes place the following values here:

|Mode|Value|
|-|-|
|GRAPHIC 0|0/$00|
|GRAPHIC 1|32/$20|
|GRAPHIC 2|96/$60|
|GRAPHIC 3|160/$A0|
|GRAPHIC 4|224/$E0|

While the standard screen editor interrupt routine is in
use, the value here determines how the screen mode will be
set up. As a result, you cannot directly change the bitmapped
or multicolor mode control bits of the VIC chip, since those
bits will be set according to the value here. You can turn off
the screen-setup portion of the screen editor IRQ routine by
storing the value 255/$FF here. This gives you direct control
over the VIC chip register settings, but disables BASIC'S ability
to change display modes.

TBC
