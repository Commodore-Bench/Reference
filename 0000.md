# $0000-$00FF

## 0 $00 D8502 <a name="00"></a>
### Data direction register for processor's on-chip I/O port
Bits 0-6 in this location control the direction of data flow for
the seven I/O (input/output) lines on the 8502 microprocessor
chip, labeled P0-P6. Setting a bit to %0 makes the corresponding line
an input, and its state can be read at the corresponding bit position
in location $01. Setting a bit to %1 makes the
corresponding line an output, and its state will be controlled
by the setting of the corresponding bit position in location
$01. The value here is initialized to 47/$2F by the IOINIT
routine [$E109], part of both the reset and RUN/STOP-RESTORE
sequences. This sets lines 0-3 and 5 for output and
lines 4 and 6 for input. Since only seven lines are provided,
bit 7 is not used. That bit will retain whatever value is written
to it, but its setting has no effect.

## 1 $01 R8502 <a name="01"></a>
### Data register for processor's on-chip I/O port
Each of the seven I/O lines on the 8502 microprocessor has a
corresponding bit in this location (bit 7 is unused). The direction
of data flow on the lines is controlled by location $00. If
an I/O port line is set for input, the corresponding bit here
will reflect the state of the input line: %0 if the line is low (0
volts), or %1 if the line is high (+5 volts). While a line is set
for input, values written to the corresponding bit have no effect.
If an I/O port line is set for output, its state will be controlled
by the corresponding bit in this location. Storing a %0
in the bit forces the output line to a low (0 volts) state, while
storing a %1 in the bit sets the line to a high (+5v state).
The I/O lines are connected as follows.

**Bits 0-1**: the lines connected to these bits control which of the
two 1K blocks of color memory will be visible at 55296-56319/
$D800-$DBFF when the I/O block is selected. For this purpose, the
lines should always be configured as outputs. Unlike
in the Commodore 64, these bits have no effect on whether
RAM or ROM is selected at a given address. In the 128, memory
management is the domain of the MMU chip. 
Bit 0 controls which block the processor sees, while bit 1
controls which block the VIC chip sees. Setting either bit to
%0 selects block 0, while a setting of %1 selects block 1. The
setting of these bits is established during the screen-setup
portion of the screen IRQ routine [$C194], That routine sets both
bits to %1 for text mode (GRAPHIC 0), or for the text portion
of the split-screen modes (GRAPHIC 2 or GRAPHIC 4). For
the bitmapped modes (GRAPHIC 1 or GRAPHIC 3) or for the
bitmapped portion of the split-screen modes, bit 1 is set to
%0. Thus, the VIC sees different blocks of memory for the
modes, and drawing on the bitmapped screen will not disturb
colors on the text screen. To manipulate these bits in other
ways, the screen-setup portion of the IRQ routine must be disabled.

**Bit 2**: the line for this bit, known as the CHAREN line, determines
whether the VIC chip will see character ROM in its current video bank.
For proper functioning, the line should be
configured as an output. While this bit is %0, the VIC chip
will see character ROM beginning at an offset of 4096/$1000
from the start of the bank. The uppercase/graphics set will
appear to occupy locations with offsets of 4096-6143/
$1000-$17FF, and the lowercase/uppercase set will appear at
offsets of 6144-8191/$1800-$lFFF. The character sets will be
visible in all VIC video banks, not just banks 0 and 2 as was
the case in the Commodore 64. Only the VIC chip will see the
character ROM at these addresses; the processor will still see
the locations as RAM or system ROM, depending on the address and
bank configuration.
To disable this feature and allow the VIC chip to see
RAM at the character set image addresses, the CHAREN bit
must be set to %1. However, this cannot normally be done directly
because this bit has a shadow at location [217/$D9](#D9). During the text
mode-setup portion of the screen editor IRQ
routine [$C194], the value of bit 2 of the shadow location is
copied into this bit. Thus, to change this bit you should set bit
2 of the shadow location instead. If the screen-setup portion of
the IRQ routine is disabled (by storing the value 255/$FF in
location [216/$D8](#D8), for example), the setting of this bit can then
be changed directly. The IRQ routine always sets this bit to
%1 for bitmapped screen modes or for the bitmapped portion
of split-screen modes.

**Bit 3**: the line for this bit is connected to the CASS WRT
(cassette write) line of the cassette port. The setting of this bit
determines whether a signal is being written to the tape. For this
purpose, the line must be configured as an output. 

**Bit 4**: the line for this bit is connected to the CASS SENSE
(cassette button sense) line of the cassette port. If the port line
is configured as an input, this bit can be read to determine
whether any buttons are currently pressed on the Datassette.
When no buttons are pressed (or when no Datassette is connected to the port),
this bit will be %1. Pressing any button
will change this bit to %0. Unfortunately, the bit merely detects whether
buttons are pressed, and cannot indicate which
specific buttons. If you press FAST FORWARD when instructed to press PLAY,
the 128 won't notice the difference.

**Bit 5**: the line for this bit controls the CASS MTR (cassette
motor) line of the cassette port. When this bit is %1 , the
power supply to the cassette motor, provided via the CASS
MTR line, is turned off. Setting this bit to %0 turns on the 9-
volt power supply to the motor. The setting of this bit is controlled by
a shadow location, the cassette motor interlock at
[192/$C0](#C0).

**Bit 6**: the line for this bit is connected to the CAPS LOCK key
on the keyboard. The line should be configured as an input to
read the state of this key. The bit will return a %1 while the
key is in the up position (CAPS LOCK off), and a %0 when
the key is down (CAPS LOCK on). The status of this bit is
read by the SCNKEY routine [$C55D] during each system
IRQ, and bit 4 of location [211/$D3](#D3) will be assigned the opposite
setting of this bit.

**Bit 7**: there is no I/O port line connected to this bit, so the
value here is meaningless. The bit always returns a %0 when
read.

## 2 $02 BANK <a name="02"></a>
### Data register for processor's on-chip I/O port
The value here determines the bank to which the JMPFAR
routine [S02E3] will jump. Because the JSRFAR routine
[$02CD] calls JMPFAR as a subroutine, the value here also determines
the destination bank for a JSRFAR. This location
should be loaded with the number (0-15) of the desired bank
before either JMPFAR or JSRFAR is used.
The BASIC SYS statement is implemented using JSRFAR.
In that case, the value here is set from the value in location
981/$03D5, which holds the parameter from the most recent
BANK statement (15/$0F by default). The BASIC routine that
searches for a token in the runtime stack [$4FAA] also uses
location 2/$02 for temporary storage.

When the monitor is entered at the break entry point
[$B003], this location is loaded with the bank number in
which the system was operating when the BRK opcode was
encountered. When the monitor is entered at the cold-start entry point
[$B000], as by the BASIC MONITOR command, this
location is initialized to 15/$0F (for bank 15). The monitor R
command displays the value in this location as the first hexadecimal
digit of the PC value. The register change (;) command can be used
to alter the value stored here. The value
determines the bank for the monitor G (go to routine) and J
(jump to subroutine) commands, which use JMPFAR and
JSRFAR, respectively.

## 3-4 $03-$04 PC <a name="03"></a><a name="04"></a>
### Target address for JMPFAR and JSRFAR
The values here determine the address to which the JMPFAR
routine [$02E3] will jump. Because the JSRFAR routine
[$02CD] calls JMPFAR as a subroutine, the value here also determines
the destination address for a JSRFAR. These locations
should be loaded with the desired address before either
JMPFAR or JSRFAR is used. Contrary to the normal order of
address bytes, the high byte of the target address should be
stored in location 3/$03 and the low byte in location 4/$04.
When the monitor is entered at the break entry point
[$3003], these locations are loaded with the program counter
contents stored on the stack when the BRK opcode was encountered.

Because of the way the microprocessor handles
BRK, this value will be two bytes beyond the address of the
BRK ($00) opcode. When the monitor is entered at the coldstart entry point
[$B000], as by the BASIC MONITOR command, these locations are initialized to
45056/$B000 (the coldstart entry address). The monitor R command displays the
value in these locations as the four rightmost hexadecimal digits of the PC value.
The register change (;) command can be
used to alter the value stored here. The value determines the
target address for the monitor G (go to routine) and J (jump to
subroutine) commands, which use JMPFAR and JSRFAR,
respectively.

## 5 $05 S-REG <a name="05"></a>
### Status register storage for JMPFAR and JSRFAR
The value in this location is transferred to the processor's status
register when a routine is called with JMPFAR [$02E3]. Because JSRFAR
[$02CD] also uses JMPFAR, the value here will
also determine the initial status register value for a routine
called with JSRFAR. You can use this location to set up particular entry
conditions for the target routine. For example,
certain system routines behave differently depending on
whether the carry bit, bit 0 of the status register, is clear (%0)
or set (%1) when the routine is called. You can specify the entry setting
of the carry bit by setting bit 0 of this location. Next figure shows the
function of the various status register bits. If
you don't need any special entry conditions, it's best to set
this location to [0/$00](#00).

The contents of the status register upon return from the
target routine are stored in this location before return from
JSRFAR, so you can read this location to determine the exit
status of the routine. This is useful because system routines
often use status register bits, particularly carry, to return information
about the success of the operation performed by the
routine.

![Processor Status Register](resources/002-01-f-processor-status-register.png)

The BASIC 7.0 version of the SYS statement allows you
to specify a status register value, which will be placed in this
location before the JSRFAR to the specified address. The
RREG statement can be used to read the value here. The status register
value returned by RREG is actually the contents of
this location.

When the monitor is entered at the break entry point
[$B003], this location is loaded with the status register contents
stored on the stack when the BRK opcode was encountered.
When the monitor is entered at the cold-start entry point
[$B000], as by the BASIC MONITOR command, this location
is initialized to zero. The monitor R command displays the
value in this location under the heading SR. The register
change (;) command can be used to alter the value stored here.
The value determines the status register contents for the monitor G
(go to routine) and J (jump to subroutine) commands,
which use JMPFAR and JSRFAR, respectively.

## 6 $06 A_REG <a name="06"></a>
### Accumulator storage for JMPFAR and JSRFAR
The value in this location is transferred to the processor's
accumulator (A register) when a routine is called with JMPFAR
[$02E3]. Because JSRFAR [$02CD] also uses JMPFAR, the
value here will also determine the initial accumulator value for
a routine called with JSRFAR. You can use this location to set
up a particular entry value for the target routine. The contents
of the accumulator upon return from the target routine are
stored in this location before return from JSRFAR, so you can
read this location to determine the exit accumulator value. The
JSRFAR routine itself uses the accumulator after return from
the target routine, so you must look to this location for the
accumulator value from the target routine.
The BASIC 7.0 version of the SYS statement allows you
to specify an accumulator value, which will be placed in this
location before the JSRFAR to the specified address. The
RREG statement can be used to read the value here.
The accumulator value returned by RREG is actually the contents of
this location.

When the monitor is entered at the break entry point
[$B003], this location is loaded with the accumulator contents
stored on the stack by the IRQ/BRK handler [$FF17]. When
the monitor is entered at the cold-start entry point [$B000], as
by the BASIC MONITOR command, this location is initialized
to zero. The monitor R command displays the value in this location
under the heading AC. The register change (;) command can be used to
alter the value stored here. The value
determines the accumulator contents for the monitor G (go to
routine) and J (jump to subroutine) commands, which use
JMPFAR and JSRFAR, respectively.

## 7 $07 X_REG <a name="07"></a>
### X register storage for JMPFAR and JSRFAR
The value in this location is transferred to the processor's X
register when a routine is called with JMPFAR [S02E3J. Because JSRFAR
[$02CD] also uses JMPFAR, the value here will
also determine the initial X register value for a routine called
with JSRFAR, You can use this location to set up a particular
entry value for the target routine. The contents of the X register
upon return from the target routine are stored in this location before
return from JSRFAR, so you can read this location to determine the exit
X register value. The JSRFAR routine itself uses the X register after
return from the target routine, so
you must look to this location for the X register value from the
target routine.
The BASIC 7.0 version of the SYS statement allows you
to specify an X register value, which will be placed in this location
before the JSRFAR to the specified address. The RREG
statement can be used to read the value here. The X register
value returned by RREG is actually the contents of this
location.

When the monitor is entered at the break entry point
[$B003], this location is loaded with the X register contents
stored on the stack by the IRQ/BRK handler [$FF17]. When
the monitor is entered at the cold-start entry point [$B000], as
by the BASIC MONITOR command, this location is initialized
to zero. The monitor R command displays the value in this location under
the heading XR. The register change (;) command
can be used to alter the value stored here. The value determines the X
register contents for the monitor G (go to routine)
and J (jump to subroutine) commands, which use JMPFAR and
JSRFAR, respectively.

## 8 $08 Y_REG <a name="08"></a>
### Y register storage for JMPFAR and JSRFAR
The value in this location is transferred to the processor's Y
register when a routine is called with JMPFAR [$02E3]. Because
JSRFAR [$02CD] also uses JMPFAR, the value here will
also determine the initial Y register value for a routine called
with JSRFAR. You can use this location to set up a particular
entry value for the target routine. The contents of the Y register
upon return from the target routine are stored in this location before
return from JSRFAR, so you can read this location
to determine the exit Y register value.
The BASIC 7.0 version of the SYS statement allows you
to specify a Y register value, which will be placed in this location
before the JSRFAR to the specified address. The RREG
statement can be used to read the value here. The Y register
value returned by RREG is actually the contents of this
location.

When the monitor is entered at the break entry point
[$B003], this location is loaded with the Y register contents
stored on the stack by the IRQ/BRK handler [$FF17]. When
the monitor is entered at the cold-start entry point [$B000], as
by the BASIC MONITOR command, this location is initialized
to zero. The monitor R command displays the value in this location
under the heading YR. The register change (;) command
can be used to alter the value stored here. The value determines the
Y register contents for the monitor G (go to routine)
and J (jump to subroutine) commands, which use JMPFAR and
JSRFAR, respectively.

## 9 $09 STKPTR <a name="09"></a>
### Stack pointer storage for JSRFAR and monitor
This location is used in the JSRFAR routine [$02CD] to record
the value in the stack pointer upon return from the target routine.
The value here doesn't affect the setting of the stack
pointer; it merely records the exit value.
When the monitor is entered via either the cold-start entry
point [$B000] or the break entry point [$B003], the current
stack pointer value is stored in this location. The monitor R
command displays the value in this location under the heading SP.

The register change (;) command can be used to alter
the value stored here. The value here is restored to the
microprocessor's stack pointer before the JMPFAR in the G (go
to routine) command routine. This location will hold the stack
pointer value after a J (jump to subroutine) command, since
that routine uses JSRFAR.

## 9 $09 CHARAC or INTEGR
### Working storage for various routines
This location is used for several different purposes by a variety
of BASIC routines. It serves as temporary storage in the routine which
interprets ASCII characters as numeric values
[$50A0]. It holds the value of the desired search character in
the routine which searches for a particular character in a
BASIC program line [$52A2], and in the routine that puts a
string into the string pool [$869A]. It holds the low byte of the
integer value generated in the BASIC INT routine [$8CFB]. It
is also used for temporary storage of intermediate values while
performing BASIC AND or OR operations [$4C86],

## 10 $0A GRAPHM <a name="0A"></a>
### Working storage for various routines
This location is used for several different purposes by a variety
of BASIC routines. It serves as a counter of the number of digits in
the ASCII representation of a number during the routine
which interprets the characters as a numeric value [$50A0]. It
holds the value of the character which terminates the search in
the routine which looks for a particular character in a BASIC
program line [$52A2], and in the one that puts a string into
the string pool [$869A]. It is also used for temporary storage of
intermediate values while performing BASIC AND or OR operations [$4C86].

## 11 $0B TRMPOS <a name="0B"></a>
### Current screen column for TAB and SPC calculations
The value in this location is used during the portion of the
BASIC PRINT routine [$5554] that handles the TAB and SPC
functions. In the computation of the target column for the TAB
or SPC, this location will hold the current cursor column
value.

## 12 $0C VERCK <a name="0C"></a>
### BASIC LOAD/VERIFY flag
The same routine is used to perform both the load and verify
operations, so this flag indicates which is being performed, A
zero value here indicates a load operation, and a nonzero
value indicates verify. The value here is set during the
LOAD/VERIFY [$9129] and DLOAD/DVERIFY [$A1A4]
routines. Both operations use the Kernal LOAD routine
[$F265], which has its own load/verify flag at location
[147/$93](#93).

## 13 $0D COUNT <a name="0D"></a>
### Working storage for various routines
This location is used for different purposes by several BASIC
routines. It holds the most recently found token during program
tokenization [$430A]. In the routine that adds or deletes
BASIC program lines [$4DE2], this location holds the length of
the current line. It is also used as a counter in the RREG routine
[$50BD], and as a counter in the subroutines that find or
create array-variable elements.

## 14 $0E DIMFLG <a name="0E"></a>
### Array dimension flag
This location is used during the routines that create array variables
to indicate whether the routines are being called to as
the result of a DIM statement. For a DIM statement, this location
will contain a nonzero value; otherwise it will be set to
0/$00. This flag is used in testing for the REDIM'D ARRAY
ERROR condition.

## 15 $0F DIMFLG <a name="0F"></a>
### Variable type flag
This location is used to indicate the type of variable currently
being evaluated. A value of 0/$00 indicates that the variable
is numeric. A nonzero value indicates that the variable is
string type. During the routine that finds or creates a variable
[$7AAF], this location is set to 0/$00 if the variable is numeric
type, or to 255/$FF if it is string type.

## 16 $10 INTFLG <a name="10"></a>
### Numeric variable type flag
If the variable currently being evaluated is numeric (see the
entry for location 15/$0F above), bit 7 of this location will be
used to indicate the numeric type. If that bit is %0, the variable
is standard (floating point) type. If the bit is %1, the variable
is integer type. During the routine that finds or creates a
variable [$7AAF], this location will be set to 0/$00 for floating
point variables or 128/$80 for integer variables.

## 17 $11 GARBFL <a name="11"></a>
### Working storage for various routines
This location is used for different purposes in several BASIC
routines. During string evaluation, it is used as a garbage
collection flag. A zero value indicates that no garbage collection has
been performed, while a nonzero value (1/$01)
indicates that garbage collection has taken place. The location
is also used as a quote mode flag during LIST; a value of
0/$00 indicates that quote mode is off, while a nonzero value
(1/$01) indicates that quote mode is in effect. In addition, this
location is used as temporary storage for the high byte of the
disk status variable during the evaluation of the reserved variable DS.

## 18 $12 SUBFLG <a name="12"></a>
### Integer/subscript prohibit flag
This location is used during the routine to find or create a
variable [$7AAF] to specify whether integer or subscripted (array)
variables are allowed. While the value here is zero, the
variable being evaluated can be of any type. The FOR and
DEF routines store the value 128/$80 here. For FOR, this prevents the
use of integer or array variables as loop indexes. For
DEF, this restricts the function definition to floating point variables
and also prevents the parentheses in the function definition from being
interpreted as indicating an array variable.
This location is reset to zero after each variable is evaluated,
and also during CLR [$51F8].

## 19 $13 INPFLG <a name="13"></a>
### Input source flag
BASIC uses a common input handling routine [$56B2] for
READ, GET (including GETKEY and GET#), and INPUT (including INPUT#).
This location is used to indicate which operation is being performed.
The value here will be 152/$98 for a
READ operation, 64/$40 for a GET, or 0/$00 for an INPUT.

## 20 $14 TANSGN <a name="14"></a>
### Comparison type flag - Tangent sign flag
The value in this location is used during the string and number
comparison routine [$4CB6] to specify the type of comparison being
performed, A value here of 1 indicates greater than
(>), 2 indicates equal ( —), and 4 indicates less than (<). The
values are cumulative, so a test for greater than or equal (> —)
would result in a value here of 3 (1 + 2). This location is also
used during the TAN function routine [$9459] to indicate the
sign of the resulting value.

## 21 $15 TANSGN <a name="15"></a>
### Logical file number for BASIC input and output
The value in this location specifies the logical file from which
BASIC will receive input and to which BASIC will direct output.
The default value is 0/$00, which indicates input from
the keyboard and output to the screen. Logical file 0 is reserved
for the system's use; you cannot open logical file 0.
Statements which get input or send output to other devices,
such as GET#, INPUT#, and PRINT*, will temporarily change
the value here to the channel number specified in the statement.
The CMD statement can also be used to change the value
here and direct all output to a specified logical file. However,
you can't depend on CMD (or POKEing a value here) to keep
all output flowing to the specified logical file. A number of
other BASIC statements reset the value here to 0/$00 each
time they are executed, restoring default input and output devices.
These statements include GET (and GET# and GETKEY),
INPUT#, and PRINT*.

## 22-23 $16-$17 LINNUM <a name="16"></a><a name="17"></a>
### Integer value of ASCII digit string
These are very busy locations, since the routine which reads
ASCII characters from program text and converts the result to
a two-byte line number value [$50A0] stores its results here.
Other routines which manipulate program lines, such as the
one which adds or deletes program lines, will use these locations to
hold the line number. Any statement which reads a
line number, including GOTO, GOSUB, LIST, and so on, will
expect to find the target line number in these locations. The
TRAP destination line number is held here during the ERROR
routine [$4D3C], and the COLLISION target line number is
held here during the GONE routine [$4A9F].
Machine language programmers can store line number
values in these locations, then jump into a BASIC routine at a
point beyond the line number evaluation step. For example, a
machine language program can enter a BASIC program at any
line number by jumping into the GOTO routine with the target line
number in these locations. The following section of
code performs the equivalent of GOTO 100:

``` Assembly
LDA #$64  // Place line number in $16-$17.
STA $16
LDA #$00
STA $17
LDA #$0F  // Bank number for BASIC ROM (15).
STA $02
LDA #$59  // Enter GOTO routine at $59FB.
STA $03
LDA #$FB
STA $04
JMP $02E3 // Use JMPFAR to call routine
```

## 24 $18 TEMPPT <a name="18"></a>
### Pointer into temporary string descriptor stack
The value in this location points to the next available slot in
the temporary string descriptor stack at 27-35/$1B-$23. This
location can have the following values:

|Value|Meaning|
|-|-|
|27/$1B|no entries (stack empty)|
|30/$1E|one entry|
|33/$21|two entries|
|36/$24|three entries (stack full)|

## 25-26 $19-$1A LASTPT <a name="19"></a><a name="1A"></a>
### Pointer to most recent descriptor stack entry
These locations hold the address of the most recent entry in
the temporary string descriptor stack at 27-35/$lB-$23. Location 25/$19
will hold the equivalent of the value in 24/$18
less three, and location 26/$lA will hold zero (it is assigned
this value during the BASIC cold-start sequence). For example,
when there are two entries on the stack, 24/$18 will hold $21,
while these two locations will hold $1E and $00, corresponding to
address $001E, the address of the second entry in the stack.

## 27-35 $1B-$23 TEMPST <a name="1B"></a><a name="23"></a>
### Temporary string descriptor stack
The three 3-byte entries here hold descriptors (length plus a 2-
byte pointer to the starting address of the string in the string
pool) for strings being evaluated or assembled. For strings being
assigned to variables, the descriptor value generated here
will be transferred to the variable table entry for that string.

## 36-37 $24-$25 INDEX <a name="24"></a><a name="25"></a>
### Multipurpose address pointer
These locations are used as an address pointer by several
BASIC routines, including the one at 927/$039F, which retrieves
characters from bank 0 (BASIC program text), and the
one at 951/$03B7, which retrieves characters from bank 1
(BASIC string storage). Numerous BASIC routines call those
character retrieval routines, including the one which inserts or
deletes program lines [$4DE2] and the one which updates
variable tags while making space for a new variable. The
pointer is also used in the LIST routine to read characters from
the keyword table, and in the floating-point routines to copy
floating values to and from the variable storage area in bank 1.
In addition, location [36/$24](#24) is used for temporary storage
during formula evaluation, and location 37/$25 is used as a
pointer into the ROM keyword tables when tokenizing program lines
[$43E2] or listing (detokenizing) program lines [$5123].

## 38-39 $26-$27 INDEX2 <a name="26"></a><a name="27"></a>
### Multipurpose address pointer
These locations are used as an address pointer by the routine
at 960/$03C0 which fetches characters from BASIC program
text in bank 0. That routine is called by several other BASIC
routines, including the one which adds or deletes program
lines. These locations are also used by the ERROR routine
[$4D3C] as a pointer to the specified error message in the message
table in ROM.

## 40-44 $28-$2C RESHO <a name="28"></a><a name="2C"></a>
### Temporary storage area for multiplication and division
This area is used to hold intermediate values during the
BASIC routines that perform floating-point multiplication and
division.

## 45-46 $2D-$2E TXTTAB <a name="2D"></a><a name="2E"></a>
### Start-of-BASIC-program pointer
The value in these locations points to the first address block 0
RAM used for BASIC program text. The value here is initialized to
7169/$1C01 during the BASIC cold-start sequence. In
the Commodore 64, the value here was initialized to the value
in the Kernal MEMSTR pointer, the bottom of memory established during
the Kernal reset sequence. However, the 128 always initializes the same
value here, without regard for the
value in MEMSTR (2565-2566/$0A05-$0A06).
The only Kernal routines that change the value here are
the ones that allocate or de-allocate a bitmapped graphics area
for the GRAPHIC statement. When a bitmapped graphics area
is allocated, BASIC program text is moved upward to start at
16385/$4001, above the bitmapped graphics area at 7168-16383/
$1C00-$3FFF. In this case, the values in these pointers will be
adjusted accordingly. The value here will be reset to
7169/$1C01 when the graphics area is de-allocated and the
BASIC program text is moved back down to its original
position.

During the NEW and RUN routines, the CHRGET pointer
([61-62/$3D-$3E](#3D)) is initialized with a value one less than the
address in these locations. You can store new values in these
locations to change the starting position of BASIC program
text—for example, if you wish to reserve free memory space in
block 0 RAM below the program. However, two other steps are
required to properly initialize the system to use the new starting
position: You must also store the value 0/$00 in the location
immediately before the address specified here (BASIC
requires that program text be preceded by a zero byte), and
you must perform a NEW to reset other pointers to reflect the
new start-of-BASIC position.
During execution of BASIC'S SAVE and DSAVE routines,
the value here determines the starting address of the data to be
saved.

## 47-48 $2F-$30 VARTAB <a name="2F"></a><a name="30"></a>
### Start-of-variables pointer
The value in these locations points to the first address in block
1 RAM used for scalar (nonarray) variable storage. The value
here is initialized to 1024/$0400 during the BASIC cold-start
sequence, and no other system routine changes that setting.
You can store new values in these locations to change the
starting position of the variable table—for example, if you
wish to reserve free memory space for data storage in block 1
RAM below the variables. However, to properly initialize the
system to use the the new starting position, you must perform
a CLR to reset other pointers to reflect the new start-of-variables
position. During the CLR routine [$51F8] {which is also performed
during NEW and BASIC cold start), the start-of-arrays
pointer ([49-50/$31-$32](#31)) and the end-of-arrays pointer
($33-$34) are also set to the value in these locations

## 49-50 $31-$32 ARYTAB <a name="31"></a><a name="32"></a>
### Start-of-arrays pointer
The value in these locations points to the first address in block
1 RAM used for the storage of array variables, which is also
one location above the last address used for array variables.
The value here is initialized to the start-of-variables value in
locations [47-48/$2F-$30](#2F) during the CLR routine [$51F8]
(which is also performed during NEW and BASIC cold start).

## 51-52 $33-$34 STREND <a name="33"></a><a name="34"></a>
### Start-of-free-memory pointer
The value in these locations points to the lowest address in
block 1 RAM available for the storage of strings, which is also
one location above the last address used for array variables.
The value here is initialized to the start-of-variables value in
locations [47-48/$2F-$30](#2F) during the CLR routine [$51F8]
(which is also performed during NEW and BASIC cold start).
When the value here equals the value in location 49-50/
$31-$32, no arrays are being used. The function FRE(l) will
return the difference between the value here and the one in
locations [53-54/$35-$36](#35), representing the remaining amount
of memory available for string storage. When the value in
[53-54/$35-$36](#35) (the FRETOP pointer) reaches the value here,
garbage collection is performed. If garbage collection cannot
remove enough unused strings to create free space between
the address here and the one pointed to by FRETOP, an OUT
OF MEMORY error occurs.

## 53-54 $35-$36 FRETOP <a name="35"></a><a name="36"></a>
### Bottom-of-string-space pointer
The value in these locations points to the lowest address in
block 1 RAM used for the string pool. All character strings
used in a BASIC program are stored in the area of block 1 between
the address pointed to in [57-58/$39-$3A](#39) and the
address pointed to here—an area called the string pool. Each
active string here will have a descriptor in the variable array
table areas at the bottom of block 1, or in the temporary descriptor
stack at [27-35/$1B-$23](#1B). The pool may also contain
inactive strings that the program is no longer using. The value
here is initialized to the top-of-memory value in locations
57-58/$39-$3A during the CLR routine [$51F8] (which is also
performed as part of NEW and the BASIC cold-start sequence).
When the value here equals the value in location
[57-58/$39-$3A](#39), no strings have yet been used. Strings are
added from the top of memory downward. When the value
here reaches the value in [51-52/$33-$34](#33), garbage collection is
performed to remove inactive strings. If garbage collection
cannot remove enough unused strings to create free space between
the address here and the one in [51-52/$33-$34](#33), an
OUT OF MEMORY error occurs. The function FRE(1) will return the
difference between the value here and the one in locations
[51-52/$33-$34](#33), the amount of free memory remaining
for string storage.

## 55-56 $37-$38 FRESPC <a name="37"></a><a name="38"></a>
### Temporary pointer into the string pool
These locations are used by the routines that add strings to the
string pool as a pointer to the currently referenced string, and
as a pointer to the current string during the garbage collection
routines.

## 57-58 $39-$3A MAX_MEM_1 <a name="39"></a><a name="3A"></a>
### Top-of-memory pointer
The value in these locations determines the highest address in
block 1 RAM available for the string pool. Actually, the address value
here will be one location beyond the highest location used for the
string pool. The string pool is filled downward from the address specified here.
The value in locations [53-54/$35-$36](#35) specifies the address of the bottom of the
pool. When the value in those locations equals the value here,
the pool is empty. The BASIC cold-start routine initializes
these locations to 65280/$FF00, one location beyond the highest
contiguous address in block 1 RAM (MMU registers are
seen at 65280-65284/$FF00-$FF04 in all memory configurations).
You can reduce the value here to reserve memory at
the top of block 1 for other purposes such as data storage.
However, when you change the value here you should also
execute a CLR statement [$51F8] to reset the other string pool
pointers.

## 59-60 $3B-$3C CURLIN <a name="3B"></a><a name="3C"></a>
### Current BASIC line number
These locations hold the line number of the BASIC program
line currently being executed. After each program line is executed,
the routine which executes BASIC program lines
[$4AF3] will load these locations with the number of the next
line to be executed. The value here is used by various other
BASIC routines that need to know which line is currently being executed.
The value here is stored in locations 4608-4609/
$1200-$1201 by the routine that processes STOP or END
[$4BCA]. The value stored in those locations will be transferred back
here by the CONT routine [$5A60]. The value
here will be stored in locations 4617-4618/$1209-$120A
when an error is processed by the ERROR routine [$4D3C].
The value in those locations will be transferred back here by
the RESUME routine [$5F62].

## 61-62 $3D-$3E TXTPTR <a name="3D"></a><a name="3E"></a>
### Pointer for main BASIC character retrieval routine
These locations serve as the pointer into BASIC text for the
CHRGET routine, BASIC'S primary character retrieval routine.
In earlier Commodore computers, the entire CHRGET routine
was in zero page. The 128's CHRGET is located higher in the
common area, beginning at address 896/$0380, and only the
pointer is kept in zero page. CHRGET is designed to retrieve
the next nonspace character of BASIC text, so the first step in
CHRGET is to increment the address here. The routine also
has an alternate entry point called CHRGOT at 902/$0386,
which retrieves the current character (the one at the address
here) without incrementing the pointer.
The NEW, RUN, and LOAD routines all call the subroutine
[$5254] which initializes this pointer to one byte before the
start-of-BASIC value in locations [45-46/$2D-$2E](#2D). Because the
CHRGET routine is so heavily used, many BASIC routines affect the
value here. For example, any of the routines which send
the program to another line, such as GOTO, GOSUB, THEN,
and so on, must replace the current value here with the address
of the target line. The value here is stored in locations
4610-4611/$1202-$1203 by the routine that processes STOP
or END [$4BCA]. The value stored in those locations will be
transferred back here by the CONT routine [$5A60]. The value
here will be stored in locations 4622-4623/$120E-$120F
when an error is processed by the ERROR routine [$4D3C],
The value in those locations may be transferred back here by
the RESUME routine [$5F62].
The value here is also used as a pointer for the alternate
character retrieval routine at 969/$03C9, which fetches the
current text character without CHRGET's test for character type.

## 63-64 $3F-$40 FNDPNT <a name="3F"></a><a name="40"></a>
### Working pointer for various routines
These locations are used as a working pointer into the runtime
stack at 2048-2559/$0800-$09FF by the routines that search
for tokens in the stack. The RENUMBER routine [$5AF8] uses
these locations as an end-of-program pointer. The PRINT
USING routine [$9520] uses the routine at 939/$03AB (which
uses these locations as a pointer) to retrieve characters from
the template pattern string in block 1 RAM.

## 65-66 $41-$42 DATLIN <a name="41"></a><a name="42"></a>
### Line number of current DATA statement
These locations hold the line number of the BASIC program
line containing the DATA statement from which DATA items
are currently being read. These locations are updated by the
subroutine that searches for the start of the next DATA statement:
[$57CA], called during execution of the READ statement. The value
here isn't used by any system routine, but it
can be very helpful when you're debugging a program containing DATA
statements. Whenever a program stops with an
ILLEGAL QUANTITY or TYPE MISMATCH error message in
a line containing a READ statement, it's very likely that the
error is actually in the DATA line rather than the line specified in
the error statement (the one which contains READ).
You can find the line number from which the last, possibly erroneous,
DATA item was read using PRINT PEEK(65) + 256 * PEEK(66).

## 67-68 $43-$44 DATPTR <a name="43"></a><a name="44"></a>
### Pointer to next DATA item
These locations are used as a pointer to the address at which
the search for the next available DATA item will begin. The
subroutine that searches for the next DATA item [$57CA],
called during execution of the READ statement, will update
the value here to point to the start of the next DATA item.
The RESTORE statement, when used without a line number
parameter, resets the value here to the starting address of
BASIC program text (from locations [45-46/$2D-$2E](#2D), That
RESTORE subroutine is also called as part of the CLR routine,
which in turn is called as part of RUN. Thus, the search for
DATA items normally begins at the first program line. The
RESTORE statement can be used with a line number parameter to
change the value here. In that case, the pointer value
will be reset to the starring address of the specified line. The
specified line need not contain a DATA statement. It merely
specifies the line from which the search for the next DATA
statement will begin.

## 69-70 $45-$46 INPPTR <a name="45"></a><a name="46"></a>
### Text pointer for input
The common input routine [$56B2], used in the execution of
the GET, GETKEY, GET#, INPUT, INPUT*, and READ statements,
uses these locations as a pointer to the characters to be
read as input. The value here will be transferred into the
CHRGET pointer at 61-62/$3D-$3E so that CHRGET can be
used to retrieve characters from the input. The GET, GETKEY,
and GET* statements will initialize the value here to
513/$0201, an input buffer location set to 0/$00 to cause the
input routine to read the next character. The INPUT and INPUT*
statements will initialize the value here to 511/$01FF, a
location immediately before the input buffer set to 44/$2C,
the code for the comma character. The actual input will be in
the input buffer beginning at 512/$0200. The READ statement
will initialize these locations with the starting address of the
next DATA item (from locations [67-68/$43-$44](#43)).

## 71-72 $47-$48 VARNAM <a name="47"></a><a name="48"></a>
### Current variable name
These locations are used during the routine to find or create a
variable [$7AAF] to hold the compressed (two-byte) form of
the specified variable name. This compressed form will then
be used as a search pattern to check whether a variable of the
same name and type currently exists. If not, the characters
here will be used as the name for the new variable.

## 73-74 $49-$4A VARPNT <a name="49"></a><a name="4A"></a>
### Pointer to variable descriptor
These locations are used as a pointer to the first byte of the
descriptor for the variable—the address of the location just beyond
the two-character name in the variable table entry for
the variable. The value here is set upon exit from the routines
to find [$7AAF] or create [$7B90] a variable. The FN (user
defined function) routine will load these locations with the
address of the descriptor for the dummy variable in the function
definition.

## 75-76 $4B-$4C FORPNT <a name="4B"></a><a name="4C"></a>
### Variable descriptor pointer and working storage
These locations are used during the routine that assigns variable
values (LET [$53C6]) as a pointer to the variable value or
string descriptor. For numeric variables, the address here will
be the location in block 1 RAM where the value will be
stored. For string variables, the address here will be the location
in block 1 RAM where the length and pointer into the
string pool for the string will be stored. The FOR statement
uses the value here to find the address of the value for the
loop index variable.
For the WAIT statement [$6C2D], location 75/$4B holds
the test byte pattern and location 76/$4C holds the mask byte
pattern. Location 75/$4B is also used as an index into the current
line during the routine to list BASIC program lines [$5123],

## 77-78 $4D-$4E VARTXT <a name="4D"></a><a name="4E"></a>
### Temporary storage for text pointer
These locations are used for temporary storage for the
CHRGET pointer value from 61-62/$3D-$3E during the common input
routine [$56B2], which uses CHRGET to retrieve
characters from the input source location. Location 77/$4D is
also used during the numeric expression evaluation routine
[$77EF] as a flag to indicate when the end of the expression
has been reached.

## 79 $4F OPMASK <a name="4F"></a>
### Relational operator flag
When the main expression evaluation routine [$77EF] finds a
relational operator (<, =, or >) in the current expression, it
stores a value here indicating which operator has been found.
For greater than (>) operations, the value here will be 1. For
equals ( = ), the value will be 2; for less than (<) it will be 4.
When the expression is evaluated, this value will be transferred to
location [20/$14](#14).

## 80-81 $50-$51 DEFPNT <a name="50"></a><a name="51"></a>
### Defined function pointer and working pointer
These locations are used by the routine that retrieves bytes
from the variable table entry for a function definition (FN).
That routine [$42CE] uses these locations as a pointer for one
of the bank 1 character retrieval subroutines [$03AB]. These
locations are also used as a working pointer by one of the
routines that reads values during garbage collection. That routine
[$42FB] also uses a bank 1 data retrieval subroutine [$03AB].
The routine that allocates the bitmapped graphics area [$9F4F]
uses these locations to hold the number of bytes that must be
moved upward to make room for the graphics area.

## 80-84 $50-$54 TEMPF3 <a name="50"></a><a name="54"></a>
### Temporary storage for floating-point value
These locations are used to temporarily hold the floating-point
value of the exponent during the routine to handle the exponentiation
(T) operator [$8FC1].

## 82-83 $52-$53 DSCPNT <a name="52"></a><a name="53"></a>
### Variable address storage and working pointer
The routine that creates space in the string poo] for a new string
variable uses these locations to temporarily store the address
of the variable table entry. These locations are also used as a
pointer by the routine that retrieves characters from the string
poo] for the LEFT$, RIGHT$/
 and MID$ functions [$42D8].

## 85 $55 HELPER <a name="55"></a>
### HELP flag
Bit 7 of this location is tested in the routine which lists BASIC
program lines [$5123] to determine whether the line is being
displayed by LIST or by HELP. When the bit is %1 , the subroutine
at 22956/$59AC will be called to highlight the portion
of the line where the most recent error occurred. The HELP
statement routine [$5986] sets bit 7 to %1 before it calls the
line-listing routine, and clears it to %0 afterwards.

## 86-88 $56-$58 JMPER <a name="56"></a><a name="56"></a>
### BASIC function execution vector
This vector is used to execute the routines that handle BASIC
functions. Location 86/$56 is initialized during the BASIC
cold-start sequence with the value 76/$4C, the 8502 JMP
opcode. The function dispatch routine [$4BF7] loads 87-88/
$57-$58 with the address of the routine that performs the desired
function operation. A JSR $0056 instruction then executes the
function-handling routine.

## 89-93 $59-$5D TEMPF1 <a name="59"></a><a name="5D"></a>
### Floating-point work area
These locations are used as a temporary floating-point work
area during the series evaluation routine [$9086] for the LOG,
SIN, COS, TAN, and ATN functions. Location 89/$59 is also
used for temporary storage during the routine [$9D7C] which
subtracts the contents of one pair of bitmapped graphics storage
locations from the contents of another pair of locations.

## 90-91 $5A-$5B ARRYPNT <a name="5A"></a><a name="5B"></a>
### Multipurpose working pointer
These locations are used as a pointer to the destination of text
being moved in the routine to add new BASIC program lines
to memory [$4DE2] and as a pointer into array space when
making room for a new variable [$7B90]. They are also used to
hold the line link value during RENUMBER [$5AF8].

## 92-93 $5C-$5D HIGHTR <a name="5C"></a><a name="5D"></a>
### Multipurpose address pointer
These locations serve as a pointer for the routine that reads
the source text being moved in the routine to add new BASIC
program lines. This routine [$42DD] uses one of the common
bank 0 character retrieval routines [$039F]. The locations serve
as a pointer in the routine to read source bytes when creating
space for new variables. This routine [$42E2] uses one of the
common bank 1 character retrieval routines [$03AB]. The locations
are used during the RENUMBER routine [$5AF8] to hold
the number of the line currently being renumbered.

## 93-95 $5D-$5F STR1 <a name="5D"></a><a name="5F"></a>
### String length and pointer for MID$
When MID$ is used as a statement [$5901] (to add characters
to a string), these locations hold the descriptor of the original
string. Location 93/$5D holds the length, and locations
94-95/$5E-$5F hold the address and are used as a pointer.

## 94-98 $5E-$62 TEMPF2 <a name="5E"></a><a name="62"></a>
### Temporary storage for floating-point value
These locations are used to store an intermediate value from
floating-point accumulator #1 (FAC1) during the series evaluation
routine [$909C] for the EXP function.

## 94-95 $5E-$5F <a name="5E"></a><a name="5F"></a>
### Working pointer for garbage collection
These locations are used as a pointer to the tag bytes for the
current string during the routine that performs string pool
garbage collection [$92EA].

## 95 $5F DECCNT <a name="5F"></a>
### Decimal point position
This location is used during the routine [$8E42] that creates a
character string representing the value in floating-point accumulator
#1 (FAC1) to hold the position within the string for
the decimal point. The location is also used as a loop counter
in the routine [$7E3E] to calculate the amount of memory
needed for an array.

## 96-98 $60-$62 STR2 <a name="60"></a><a name="62"></a>
### Substring length and pointer for MID$
When MID$ is used as a statement [$5901] (to add characters
to a string), these locations hold the descriptor of the substring
to be added. Location 96/$60 holds the length, and locations
97-98/$61-$62 hold the address and are used as a pointer.

## 96-104 $60-$68 T0-T2 <a name="60"></a><a name="68"></a>
### Monitor zero-page pointers and working storage
These locations are used by many routines in the monitor. The
monitor routine [$B7CE] that determines the numeric value of
a parameter in the input buffer leaves the value in locations
96-98/$60-$62 (in low- to high-byte order), so any numeric
value in a monitor command is at least initially held there. For
monitor commands that accept two or more address parameters, the
first address is transferred into locations 102-104/
$66-$68, and the value there is then used as a working
pointer to the byte to be read or written. (The monitor's indirect
fetch [$B11A], indirect store [$B12A], and indirect compare
[$B13D] routines use 102-103/$66-$67 for the address pointer
and 104/$68 for the bank value.) The starting address is subtracted
from the ending address, and the result is transferred
to 99-101/$63-$65. The value in those locations is then used
as a count of bytes to be affected by the operation. The
compare/transfer routine [$B231], which accepts three address
parameters, uses 102-104/$66-$68 as the pointer to the
source address for the compare or transfer and 96-98/$60-$62
as the pointer to the destination address.
Some monitor routines also make alternate use of some of
these locations. The memory display routine [$B152] uses
96-98/$60-$62 as a count of lines to be displayed. During assembly
[$B406], 99/$63 holds the length of the current instruction, and
location 100/$64 holds the addressing mode
type. Locations 99-100/$63-$64 are used to unpack mnemonics during
disassembly [$B6A1], and 99/$63 serves as a
counter during directory display [$BB03].

## 97-98 $61-$62 LOWTR <a name="61"></a><a name="62"></a>
### Multipurpose address pointer
A wide variety of BASIC routines use these locations as a
pointer. They serve as the pointer for a heavily used routine
[$42EC] to read characters from BASIC program text. (That
routine uses one of the common bank 0 character retrieval
subroutines [$039F].) The routine is called by the routine
which adds or deletes program lines [$4DE2], the one which
searches for a line number [$5064] (in which case the starting
address of the line is returned in these locations), LIST
[$50E2], and DELETE [$5E87]. These locations also serve as
the pointer for a routine [$4300] to read values from the variable
table. That routine uses one of the common bank 1 character retrieval
subroutines [$03AB].

The routine is called by
the routine [$7AAF] which searches the variable table to check
whether a variable with a specified name already exists, and
the one [$7CAB] which performs a similar search for array
names. If an existing name is found, the address of the table
entry for the variable or array will be returned in these
locations.



TBC

## 216 $D8 GRAPHM <a name="D8"></a>
### Target bank for JMPFAR and JSRFAR

This location is used during the screen IRQ routine [$C194] to
determine which display mode is selected for the 40-column
(VIC) screen. The value here has no effect on the 80-column
(VDC) screen. When this location contains 0/$00, text mode is
selected. Bits 5-7 control the graphics mode configurations:

|Bit|Bit value|Mode selected|
|-|-|-|
|5|32/$20  | bitmapped|
|6|64/$40  | split bitmapped/text|
|7|128/$80 | multicolor|

More than one of these can be selected at one time. The standard
graphics modes place the following values here:

|Mode|Value|
|-|-|
|GRAPHIC 0|0/$00|
|GRAPHIC 1|32/$20|
|GRAPHIC 2|96/$60|
|GRAPHIC 3|160/$A0|
|GRAPHIC 4|224/$E0|

While the standard screen editor interrupt routine is in
use, the value here determines how the screen mode will be
set up. As a result, you cannot directly change the bitmapped
or multicolor mode control bits of the VIC chip, since those
bits will be set according to the value here. You can turn off
the screen-setup portion of the screen editor IRQ routine by
storing the value 255/$FF here. This gives you direct control
over the VIC chip register settings, but disables BASIC'S ability
to change display modes.

TBC
