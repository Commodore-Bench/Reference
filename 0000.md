# $0000-$00FF

## 0 $00 D8502 <a name="00"></a>
### Data direction register for processor's on-chip I/O port
Bits 0-6 in this location control the direction of data flow for
the seven I/O (input/output) lines on the 8502 microprocessor
chip, labeled P0-P6. Setting a bit to %0 makes the corresponding line
an input, and its state can be read at the corresponding bit position
in location $01. Setting a bit to %1 makes the
corresponding line an output, and its state will be controlled
by the setting of the corresponding bit position in location
$01. The value here is initialized to 47/$2F by the IOINIT
routine [$E109], part of both the reset and RUN/STOP-RESTORE
sequences. This sets lines 0-3 and 5 for output and
lines 4 and 6 for input. Since only seven lines are provided,
bit 7 is not used. That bit will retain whatever value is written
to it, but its setting has no effect.

## 1 $01 R8502 <a name="01"></a>
### Data register for processor's on-chip I/O port
Each of the seven I/O lines on the 8502 microprocessor has a
corresponding bit in this location (bit 7 is unused). The direction
of data flow on the lines is controlled by location $00. If
an I/O port line is set for input, the corresponding bit here
will reflect the state of the input line: %0 if the line is low (0
volts), or %1 if the line is high (+5 volts). While a line is set
for input, values written to the corresponding bit have no effect.
If an I/O port line is set for output, its state will be controlled
by the corresponding bit in this location. Storing a %0
in the bit forces the output line to a low (0 volts) state, while
storing a %1 in the bit sets the line to a high (+5v state).
The I/O lines are connected as follows.

**Bits 0-1**: the lines connected to these bits control which of the
two 1K blocks of color memory will be visible at 55296-56319/
$D800-$DBFF when the I/O block is selected. For this purpose, the
lines should always be configured as outputs. Unlike
in the Commodore 64, these bits have no effect on whether
RAM or ROM is selected at a given address. In the 128, memory
management is the domain of the MMU chip. 
Bit 0 controls which block the processor sees, while bit 1
controls which block the VIC chip sees. Setting either bit to
%0 selects block 0, while a setting of %1 selects block 1. The
setting of these bits is established during the screen-setup
portion of the screen IRQ routine [$C194], That routine sets both
bits to %1 for text mode (GRAPHIC 0), or for the text portion
of the split-screen modes (GRAPHIC 2 or GRAPHIC 4). For
the bitmapped modes (GRAPHIC 1 or GRAPHIC 3) or for the
bitmapped portion of the split-screen modes, bit 1 is set to
%0. Thus, the VIC sees different blocks of memory for the
modes, and drawing on the bitmapped screen will not disturb
colors on the text screen. To manipulate these bits in other
ways, the screen-setup portion of the IRQ routine must be disabled.

**Bit 2**: the line for this bit, known as the CHAREN line, determines
whether the VIC chip will see character ROM in its current video bank.
For proper functioning, the line should be
configured as an output. While this bit is %0, the VIC chip
will see character ROM beginning at an offset of 4096/$1000
from the start of the bank. The uppercase/graphics set will
appear to occupy locations with offsets of 4096-6143/
$1000-$17FF, and the lowercase/uppercase set will appear at
offsets of 6144-8191/$1800-$lFFF. The character sets will be
visible in all VIC video banks, not just banks 0 and 2 as was
the case in the Commodore 64. Only the VIC chip will see the
character ROM at these addresses; the processor will still see
the locations as RAM or system ROM, depending on the address and
bank configuration.
To disable this feature and allow the VIC chip to see
RAM at the character set image addresses, the CHAREN bit
must be set to %1. However, this cannot normally be done directly
because this bit has a shadow at location 217/$D9. During the text
mode-setup portion of the screen editor IRQ
routine [$C194], the value of bit 2 of the shadow location is
copied into this bit. Thus, to change this bit you should set bit
2 of the shadow location instead. If the screen-setup portion of
the IRQ routine is disabled (by storing the value 255/$FF in
location [216/$D8](#D8), for example), the setting of this bit can then
be changed directly. The IRQ routine always sets this bit to
%1 for bitmapped screen modes or for the bitmapped portion
of split-screen modes.

**Bit 3**: the line for this bit is connected to the CASS WRT
(cassette write) line of the cassette port. The setting of this bit
determines whether a signal is being written to the tape. For this
purpose, the line must be configured as an output. 

**Bit 4**: the line for this bit is connected to the CASS SENSE
(cassette button sense) line of the cassette port. If the port line
is configured as an input, this bit can be read to determine
whether any buttons are currently pressed on the Datassette.
When no buttons are pressed (or when no Datassette is connected to the port),
this bit will be %1. Pressing any button
will change this bit to %0. Unfortunately, the bit merely detects whether
buttons are pressed, and cannot indicate which
specific buttons. If you press FAST FORWARD when instructed to press PLAY,
the 128 won't notice the difference.

**Bit 5**: the line for this bit controls the CASS MTR (cassette
motor) line of the cassette port. When this bit is %1 , the
power supply to the cassette motor, provided via the CASS
MTR line, is turned off. Setting this bit to %0 turns on the 9-
volt power supply to the motor. The setting of this bit is controlled by
a shadow location, the cassette motor interlock at
[192/$C0](#C0).

**Bit 6**: the line for this bit is connected to the CAPS LOCK key
on the keyboard. The line should be configured as an input to
read the state of this key. The bit will return a %1 while the
key is in the up position (CAPS LOCK off), and a %0 when
the key is down (CAPS LOCK on). The status of this bit is
read by the SCNKEY routine [$C55D] during each system
IRQ, and bit 4 of location [211/$D3](#D3) will be assigned the opposite
setting of this bit.

**Bit 7**: there is no I/O port line connected to this bit, so the
value here is meaningless. The bit always returns a %0 when
read.

## 2 $02 BANK <a name="02"></a>
### Data register for processor's on-chip I/O port
The value here determines the bank to which the JMPFAR
routine [S02E3] will jump. Because the JSRFAR routine
[$02CD] calls JMPFAR as a subroutine, the value here also determines
the destination bank for a JSRFAR. This location
should be loaded with the number (0-15) of the desired bank
before either JMPFAR or JSRFAR is used.
The BASIC SYS statement is implemented using JSRFAR.
In that case, the value here is set from the value in location
981/$03D5, which holds the parameter from the most recent
BANK statement (15/$0F by default). The BASIC routine that
searches for a token in the runtime stack [$4FAA] also uses
location 2/$02 for temporary storage.

When the monitor is entered at the break entry point
[$B003], this location is loaded with the bank number in
which the system was operating when the BRK opcode was
encountered. When the monitor is entered at the cold-start entry point
[$B000], as by the BASIC MONITOR command, this
location is initialized to 15/$0F (for bank 15). The monitor R
command displays the value in this location as the first hexadecimal
digit of the PC value. The register change (;) command can be used
to alter the value stored here. The value
determines the bank for the monitor G (go to routine) and J
(jump to subroutine) commands, which use JMPFAR and
JSRFAR, respectively.

## 3-4 $03-04 PC <a name="03"></a><a name="04"></a>
### Target address for JMPFAR and JSRFAR
The values here determine the address to which the JMPFAR
routine [$02E3] will jump. Because the JSRFAR routine
[$02CD] calls JMPFAR as a subroutine, the value here also determines
the destination address for a JSRFAR. These locations
should be loaded with the desired address before either
JMPFAR or JSRFAR is used. Contrary to the normal order of
address bytes, the high byte of the target address should be
stored in location 3/$03 and the low byte in location 4/$04.
When the monitor is entered at the break entry point
[$3003], these locations are loaded with the program counter
contents stored on the stack when the BRK opcode was encountered.

Because of the way the microprocessor handles
BRK, this value will be two bytes beyond the address of the
BRK ($00) opcode. When the monitor is entered at the coldstart entry point
[$B000], as by the BASIC MONITOR command, these locations are initialized to
45056/$B000 (the coldstart entry address). The monitor R command displays the
value in these locations as the four rightmost hexadecimal digits of the PC value.
The register change ();) command can be
used to alter the value stored here. The value determines the
target address for the monitor G (go to routine) and J (jump to
subroutine) commands, which use JMPFAR and JSRFAR,
respectively.

## 5 $05 S-REG <a name="05"></a>
### Status register storage for JMPFAR and JSRFAR
The value in this location is transferred to the processor's status
register when a routine is called with JMPFAR [$02E3]. Because JSRFAR
[$02CD] also uses JMPFAR, the value here will
also determine the initial status register value for a routine
called with JSRFAR. You can use this location to set up particular entry
conditions for the target routine. For example,
certain system routines behave differently depending on
whether the carry bit, bit 0 of the status register, is clear (%0)
or set (%1) when the routine is called. You can specify the entry setting
of the carry bit by setting bit 0 of this location. Next figure shows the
function of the various status register bits. If
you don't need any special entry conditions, it's best to set
this location to [0/$00](#00).

The contents of the status register upon return from the
target routine are stored in this location before return from
JSRFAR, so you can read this location to determine the exit
status of the routine. This is useful because system routines
often use status register bits, particularly carry, to return information
about the success of the operation performed by the
routine.

![Processor Status Register](resources/002-01-f-processor-status-register.png)

The BASIC 7.0 version of the SYS statement allows you
to specify a status register value, which will be placed in this
location before the JSRFAR to the specified address. The
RREG statement can be used to read the value here. The status register
value returned by RREG is actually the contents of
this location.

When the monitor is entered at the break entry point
[$B003], this location is loaded with the status register contents
stored on the stack when the BRK opcode was encountered.
When the monitor is entered at the cold-start entry point
[$B000], as by the BASIC MONITOR command, this location
is initialized to zero. The monitor R command displays the
value in this location under the heading SR. The register
change (;) command can be used to alter the value stored here.
The value determines the status register contents for the monitor G
(go to routine) and J (jump to subroutine) commands,
which use JMPFAR and JSRFAR, respectively.


TBC

## 216 $D8 GRAPHM <a name="D8"></a>
### Target bank for JMPFAR and JSRFAR

This location is used during the screen IRQ routine [$C194] to
determine which display mode is selected for the 40-column
(VIC) screen. The value here has no effect on the 80-column
(VDC) screen. When this location contains 0/$00, text mode is
selected. Bits 5-7 control the graphics mode configurations:

|Bit|Bit value|Mode selected|
|-|-|-|
|5|32/$20  | bitmapped|
|6|64/$40  | split bitmapped/text|
|7|128/$80 | multicolor|

More than one of these can be selected at one time. The standard
graphics modes place the following values here:

|Mode|Value|
|-|-|
|GRAPHIC 0|0/$00|
|GRAPHIC 1|32/$20|
|GRAPHIC 2|96/$60|
|GRAPHIC 3|160/$A0|
|GRAPHIC 4|224/$E0|

While the standard screen editor interrupt routine is in
use, the value here determines how the screen mode will be
set up. As a result, you cannot directly change the bitmapped
or multicolor mode control bits of the VIC chip, since those
bits will be set according to the value here. You can turn off
the screen-setup portion of the screen editor IRQ routine by
storing the value 255/$FF here. This gives you direct control
over the VIC chip register settings, but disables BASIC'S ability
to change display modes.

TBC
