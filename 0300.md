---
layout: default
title: $0300-$03FF - Basic/Kernal indirect vectors, Screen editor tables, Kernal file tables, Basic working storage
---
# $0300-$03FF - Basic/Kernal indirect vectors, Screen editor tables, Kernal file tables, Basic working storage

# BASIC Indirect Vectors
The next nine vectors, 768-785/$0300-$0311, are used in
BASIC statement processing routines. The default values for
these vectors are copied from a table at 16999-17016/$4267-$4278
in BASIC ROM by the BASIC vector initialization routine
[$4251](4000#4251), part of the cold-start sequence. Thus,
unlike the Kernal indirect vectors, the BASIC vectors are not
affected by the RUN/STOP-RESTORE sequence. Any changes
you make to the vectors will remain in effect until the next
cold start of BASIC, as during a reset.

## 768-769 $0300-$0301 IERROR <a name="0300"></a>
### Indirect vector for BASIC error handling routine
In BASIC ROM, the jump through this vector is taken at the
beginning of the error handling routine (ERROR [$4D3C](4000#4D3C)). At
the point the jump is taken, the X register will contain the
current BASIC error number (0-41, or 128 to print READY) and
the accumulator will hold the last character read from program
text. The default target address of the vector is [$4D3F](4000#4D3F),
which simply reenters the error handling routine at the point
immediately following the jump. You can redirect this vector
to change the way BASIC handles errors.

In addition to modifying error handling, you can also use
this vector to provide an alternate method of adding commands to BASIC.

## 770-771 $0302-$0303 IMAIN <a name="0302"></a>
### Indirect vector in main BASIC loop
The jump through this indirect vector is taken in the main
BASIC direct mode routine [$4DB7](4000#4DB7) at the point immediately
after the READY prompt has been printed and the mode flag
(127/$7F) has been set for immediate mode. The vector normally
holds [$4DC6](4000#4DC6), the address of the instruction immediately
following the indirect jump. You can redirect this
vector to a routine of your own if you wish to change the behavior of
BASIC's immediate mode. 

## 772-773 $0304-$0305 ICRNCH <a name="0304"></a>
### Indirect vector in BASIC tokenization routine
The jump through this indirect vector is taken at the beginning of
the CRUNCH routine [$430A](4000#430A), which is responsible
for converting lines of input text into tokenized program lines.

The vector normally holds [$430D](4000#430D), the address of the
instruction immediately following the indirect jump. You can
redirect this vector to a routine of your own if you wish to
change the way program lines are tokenized. 

## 774-775 $0306-$0307 IQPLOP <a name="0306"></a>
### Indirect vector in BASIC detokenization routine
The jump through this indirect vector is taken in the QPLOP
routine [$5123](4000#5123) at the point where the accumulator contains
the next character to be listed from the program line. The vector
normally holds [$5151](4000#5151), the address of the instruction
immediately following the indirect jump. You can redirect
this vector to a routine of your own if you wish to change the
way program lines are listed. 

## 776-777 $0308-$0309 IGONE <a name="0308"></a>
### Indirect vector in BASIC execution routine 
The jump through this indirect vector is taken at the beginning
of the GONE routine [$4F92](4000#4F92), the routine to execute a
program line. The vector normally holds [$4AA2](4000#4AA2), the
address of the instruction immediately following the indirect
jump. You can redirect this vector to a routine of your own if
you wish to change the way program lines are executed. 

## 778-779 $030A-$030B IEVAL <a name="030A"></a>
### Indirect vector in BASIC evaluation routine 
The jump through this indirect vector is taken at the beginning
of the EVAL routine, which determines the value of the
next variable, string, or number in the program. The vector
normally holds [$78DA](4000#78DA), the address of the instruction
immediately following the indirect jump. You can redirect this
vector to a routine of your own if you wish to change the way
values are evaluated. 

## 780-781 $030C-$030D ICRNCH2 <a name="030C"></a>
### Indirect vector for tokenizing additional keywords 
The jump through this vector is taken in the tokenization routine
at the point where the first character of the keyword has
been read into the accumulator and the carry bit has been set.
H carry is still set upon return from this jump, the tokenization
process will proceed normally. The vector normally holds
[$4321](4000#4321), the address of the instruction immediately following
the jump. Thus, the jump normally has no effect. If
you want to add extended tokens to BASIC, you should redirect this
vector to your routine to tokenize the new keywords.
The routine should compare the text pointed to by [$3D-$3E](0000#3D)
with the target keyword. If a match is found, your
routine should return with the second byte of the two-byte extended
token in the accumulator. The X register should be set
to indicate whether the keyword is a statement or a function.
X should be set to 0/$00 for a function, in which case the first
byte will be 206/$CE, or to 255/$FF for a statement, in which
case the first byte will be 254/$FE. The Y register should contain
the length of the filename. Finally, you should make sure
that the carry bit is clear upon exit so that your new token will
be properly processed.

## 782-783 $030E-$030F IQPLOP2 <a name="030E"></a>
### Indirect vector for detokenizing additional keywords 
The jump through this indirect vector is taken in the routine
that lists BASIC program lines at the point where two-byte extended
statement or function tokens have been found which
are greater than the largest standard tokens. When the jump is
taken, the accumulator will hold the second byte of the offending
token and the X register will hold 0/$00 if the first
byte was 206/$CE, indicating an extended function token, or
255/$FF if the first byte was 254/$FE, indicating an extended
statement token. The status register carry bit will also be set. If
that bit is still set upon return from this indirect jump, the
character will simply be printed. However, if carry is cleared,
the extended keyword will be listed. The vector normally
holds 20941/$51CD, the address of the instruction immediately
following the indirect jump, so carry will normally remain set.
If you add new extended keywords to BASIC, you
should change this vector to point to the routine to support
listing the keywords. 

## 784-785 $0310-$0311 IGONE2 <a name="0310"></a>
### Indirect vector in extended statement execution subroutine
The jump through this indirect vector is taken in the statement
execution routine at the point where a two-byte extended
statement token has been found with a value greater than one
of the standard extended statement tokens (second byte
greater than 38/$26). When the jump is taken, the accumulator
will hold the second byte of the extended token and the
carry bit will be set. If the carry bit is not clear upon return, a
SYNTAX error will be generated. The vector normally holds
19369/$4BA9, the address of the instruction immediately following
the indirect jump. Thus, the out-of-range token will
normally cause an error. If you add new extended-token statements
to BASIC, you should change this vector to point to the
address of the routine which executes the new statement.

## 786-787 $0312-$0313 Unused <a name="0312"></a>
These two locations are not used for any system vector, and
are thus available for your programming. For example, you
could use these locations to set up an indirect vector in one of
your own programs, or to store the original value when
changing one of the other vectors. 

# Kernal Indirect Vectors
The next 16 vectors, 788-819/$0314-$0333, are initialized
from a table at 57459-57490/$E073-$E092 in Kernal ROM by
the RESTOR routine [$E056](4000#E056). The RESTOR routine is called
during both the reset and RUN/STOP-RESTORE sequences,
so either of those will reinitialize the vectors. The values in
this vector table can be read or modified using the Kernal
VECTOR routine [$E05B](4000#E05B). 

## 788-789 $0314-$0315 IIRQ <a name="0314"></a>
### Indirect vector to IRQ interrupt handling routine
When an IRQ interrupt occurs or a BRK instruction is executed,
a jump is automatically taken through the processor
IRQ vector at [$FFFE](E000#FFFE) to the handling routine at
[$FF17](E000#FF17). That routine stores the accumulator, X and Y register,
and bank configuration values on the stack, then checks
whether the routine was called as the result of an IRQ or a
BRK. If an IRQ was responsible, a jump is taken through this
indirect vector. The vector normally holds 64101/$FA65, the
address of the standard system IRQ routine. You can redirect
this vector to a routine of your own to add custom steps to the
IRQ process. However, your target routine must be visible in
bank 15, since that is how memory will be configured when
the jump through this vector is taken. If your routine does not
jump to the standard IRQ handler, it must exit by jumping to
the common IRQ exit routine at [$FF33](E000#FF33). 

## 790-791 $0316-$0317 IBRK <a name="0316"></a>
### Indirect vector to BRK instruction handling
When an IRQ interrupt occurs or a BRK instruction is executed,
a jump is automatically taken through the processor
IRQ vector at [$FFFE](E000#FFFE) to the handling routine at
[$FF17](E000#FF17). That routine stores the accumulator, X and Y register,
and bank configuration values on the stack, then checks
whether the routine was called as the result of an IRQ or a
BRK. If the execution of a BRK was responsible, a jump is
taken through this indirect vector. The vector normally holds
[$B003](B000#B003), the address of the BRK entry into the machine
language monitor. You can redirect this vector to a routine of
your own if you want some other handling of BRK
instructions. 

## 792-793 $0318-$0319 INMI <a name="0318"></a>
### Indirect vector to NMI interrupt handling routine 
When an NMI interrupt occurs, a jump is automatically taken
through the processor NMI vector at [$FFFA](E000#FFFA) to the NMI
handling routine at [$FF05](E000#FF05). That routine stores the accumulator,
X and Y register, and bank configuration values on
the stack, then configures the system for bank 15 and takes a
jump through this indirect vector. The vector normally holds
[$FA40](E000#FA40), the address of the standard system NMI service
routine. You can redirect this vector to a routine of your own
to add custom steps to the NMI process. However, your routine must
be in an area of memory visible in bank 15, since
that is how memory will be configured when the jump is
taken. If your routine does not jump to the standard NMI handler,
it must exit by jumping to the common IRQ exit routine
at [$FF33](E000#FF33). 

## 794-795 $031A-$031B IOPEN  <a name="031A"></a>
### Indirect vector to Kernal OPEN routine 
This vector is the normal link between the Kernal jump table
entry at [$FFC0](E000#FFC0) and the OPEN routine at [$EFBD](E000#EFBD).
You can redirect this vector to a routine of your own if
you wish to modify the behavior of OPEN. 








