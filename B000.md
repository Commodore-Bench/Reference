---
layout: default
title: $B000-$BFFF - Monitor Jump Table
---

# $B000-$BFFF - Monitor Jump Table

The duplicate use of the word monitor in computer terminology
may be confusing at first. The term can refer to either hardware,
a dedicated video screen used to display information
from the computer, or software, a program used to examine
and modify the contents of memory. Once you understand the
difference, the meaning of monitor is usually obvious from the
context. This chapter describes the 128's built-in software monitor,
which resides in the 4K block of ROM from 45056-49151/
$BOOO-$BFFF. In addition to examining and changing memory,
this monitor allows you to assemble, disassemble, and execute
ML routines; examine and change microprocessor register contents;
and copy, compare, save, load, and verify blocks of
memory.

Like the 128's BASIC, its machine language monitor has a
long heritage from previous Commodore models. All of the
original CBM models (except for very early PETs) included a
rudimentary monitor in ROM which allowed users to examine
and modify memory and registers, execute ML programs, and
load and save data, but had no provision for assembling or
disassembling machine language.

The VIC-20 and Commodore 64 had no monitor in builtin ROM, but
sophisticated monitors for both were available on
cartridge. A number of public-domain RAM-resident monitors
were also available, most notably Supermon and Micromon.
Finally, the Plus/4 and 16 once again included a monitor
program in ROM, a version called Tedmon.

The 128's monitor shares many characteristics with all of
its predecessors, but it includes a number of enhancements as
well. One of the most notable is that it allows the entry of
numbers in decimal, octal, or binary in addition to hexadecimal.
Whenever the monitor expects a number, you can use a
decimal value if it's prefixed with a + character, or a binary
number if it's prefixed with a % character (in the rare case
when you might want to use an octal-base 8-number, pre
fix it with an ampersand, &). If no prefix is used, then hexadecimal
is assumed. (Hex can also be explicitly specified by
using a $ character as a prefix.)

## Moving Between BASIC and the Monitor
In general, the monitor is aloof from the rest of the 128 ROM
routines. Unlike BASIC-which in a number of places bypasses the
Kernal jump table and calls Kernal routines directly-the monitor
calls all the Kernal routines it uses
through their formal jump table entries. Neither BASIC nor
the Kernal calls any monitor routines other than through jump
table entries. The monitor does not make use of any BASIC
ROM routines or data tables and for the most part does not
interfere with memory locations used by BASIC. Thus, you may
pass freely back and forth between the monitor and BASIC
without fear of upsetting the BASIC program currently in
memory. This greatly enhances the monitor's function as a debugging tool.

One notable-and highly unfortunate-exception to this
independence from BASIC is that the monitor uses addresses
in the range 96-104/$60-$68 as working pointers in most operations.
This area includes the addresses used by BASIC for
its floating-point accumulator 1 (FAC1), where the results of
mathematical operations are stored. As a result, it is impossible
to use the 128's monitor to directly examine or change the
contents of FACl. This severely limits the usefulness of the
monitor for experimenting with BASIC floating-point routines.

One other overlap between BASIC and the monitor is that
the two share the same input buffer area for accepting and
processing commands (512-673/$0200-$02A1). Thus, it is not
possible to use the monitor to examine the BASIC input buffer
contents or to manipulate data in the input buffer, since the
buffer will be at least partially overwritten by the monitor
command to display or change the memory area.

## Memory Management
Another particularly attractive feature of the 128's monitor is
the ease with which it interfaces with the computer's memory
management system. Addresses in monitor commands are
specified as five-digit hexadecimal values, where the first digit
refers to the bank and the remaining four specify the address
within the bank. Monitor commands that accept a range of addresses
can span banks-T E0000 E0FFF 1C000, for example.
Thus, the monitor can effectively see the 16 separate banks as
a single 1024K (16 * 64K) block of memory. One exception is
the F (fill memory) command, which cannot cross bank boundaries, because doing so would overwrite the vital contents of
locations $00 and $01.

The fact that the monitor can see the 128's memory as a
continuous block has an important consequence for the H
(hunt for byte pattern) command. Remember that the banks
are not really 16 separate blocks of memory, but rather 16
different arrangements of the available RAM and ROM. The
lowest 1K of memory (including the input buffer at 512/$0200) is
common to all banks, and at least the lower 4K of block 0
RAM (including the buffer at 2688/$0A80, where the search
pattern is stored) appears in all even-numbered banks and in
banks 13/$0 and 15/$F.

Thus, if you search any bank from beginning to end (for
example, H 10000 1FFFF 'C-128), you'll always find at least
one match for your search pattern-in the input buffer at
$0200, where the search command is stored. If you search any
even-numbered bank from beginning to end, you'll find at
least two matches for your search pattern-once in the input
buffer at $0200 and again in the search buffer at $OA80. And
if you search all banks from beginning to end (for example, H
00000 FFFFF 'COMPUTE!), then you'll always find at least 26
matches because of all the times the memory areas used by
the input buffer and search buffer appear in the different
banks. It's important to choose your address range carefully
when searching for a byte pattern.

A final note on banks and the monitor: If no bank is explicitly
specified, bank 0 is assumed. This is different from
BASIC, which retains the setting specified in a previous BANK
statement, starting with a default of bank 15. So when using
the monitor, you must always explicitly specify the bank if
you wish to use any bank other than bank O. It is particularly
important to remember this when using the G and J commands, lest
you send the processor off to some uncharted region of memory.

For the programmer wishing to make use of ROM
routines, those in the monitor are generally less useful than
those in the BASIC, screen editor, and Kernal portions of the
ROM. The monitor JMPs rather than JSRs to the routines used
to perform monitor commands, so most major routines end by
jumping directly back to the monitor's main loop rather than
with an RTS opcode. You probably wouldn't want to incorporate
calls to such routines in your own programs because the
routines never return from the monitor. However, the main
command execution routines use a number of subroutines that
do end with RTS opcodes, and you may find some of these
useful, particularly the routines to convert and print byte
values as decimal numbers (at 47623/$BA07 and 47687/$BA47)
or as hexadecimal numbers (at 47250/$B892).

# Monitor Jump Table
Like the BASIC, screen editor, and Kernal jump tables, each
three-byte entry in the following table consists of a JMP
opcode followed by the address of an important routine.

## 45056 $B000 JMONINIT <a name="B000"></a>
### Monitor cold-start entry point
<div class="tooltip_code" onclick="loadDisasmCode('disasm\\disasm-B000.html');">Disassembled code</div>
<span class="badge badge-info">Jumps to [$B021](#B021)</span>
Enters the monitor with default microprocessor register values.
This is the entry point when the RUN/STOP key is held
down during power-on/reset, or when the MONITOR command is executed in BASIC.

## 45059 $B003 JMONBRK <a name="B003"></a>
### Monitor break entry point
<div class="tooltip_code" onclick="loadDisasmCode('disasm\\disasm-B003.html');">Disassembled code</div>
<span class="badge badge-info">Jumps to [$B009](#B009)</span>

Enters the monitor with the current program counter, bank, and
microprocessor A, X, and Y register values preserved. The
monitor is normally called via this entry point whenever a
BRK opcode is executed because the Kernal RESTOR routine
[$E056](E000#E056), part of the RESET sequence, initializes the CBINV
vector at [$0316-$0317](0300#0316) to point here. CBINV determines
where control is passed after a BRK.

## 45062 $B006 JIMONRTN <a name="B006"></a>
### Reentry point from the IMON indirect vector.
<div class="tooltip_code" onclick="loadDisasmCode('disasm\\disasm-B006.html');">Disassembled code</div>
Like the BASIC
and Kernal indirect vectors, the monitor's command execution
routine has an indirect vector, IMON ([$032E-$032F](0300#032E)),
which is initialized by the Kernal RESTOR routine [$E056](E000#E056) to
point here. From this point, control is transferred back to
[$B0B2](#B0B2) in the main loop, the address immediately following
the IMON jump. See IMON for information on how
the indirect vector can be used to wedge in additional monitor
commands.

## 45065 $B009 MONBRK <a name="B009"></a>
### Monitor entry routine when BRK instruction encountered
<div class="tooltip_code" onclick="loadDisasmCode('disasm\\disasm-B009.html');">Disassembled code</div>
Prints BREAK and a {BELL} character, then retrieves and
stores the bank number, program counter, and microprocessor
register values that were placed on the stack by the IRQ/BRK
handling routine [$FF17], then branches into the following
routine to fall through to the register display and main loop.

## 45089 $B021 MONINIT <a name="B021"></a>
### Cold-start routine for monitor
<div class="tooltip_code" onclick="loadDisasmCode('disasm\\disasm-B021.html');">Disassembled code</div>
Switches to bank 15, loads all register storage locations with
zeros, sets the program counter storage to $B000 and bank
storage to 15, and prints MONITOR. Next (at $B046) the stack
pointer is stored and Kernal error messages are enabled. The
routine then falls through to display the stored register values
and enter the main loop.

## 45136 $B050 SHOVVREG <a name="B050"></a>
### Handles R (register display) command
<div class="tooltip_code" onclick="loadDisasmCode('disasm\\disasm-B050.html');">Disassembled code</div>
Prints a heading for the register display, then displays the contents
of the storage locations (2-9/$02-$09) that represent the
program counter (prefixed with the current bank number); status;
and A, X, Y, and stack pointer register values. The storage locations
are filled upon entry to the monitor and can be changed
with the register change (;) command. To simplify the process
of changing register values, this routine adds a semicolon before
the displayed values so that you can change the stored values
by typing over the displayed values and pressing RETURN.
The routine ends by falling through into the main loop.

## 45195 $B08B MONMAIN <a name="B08B"></a>
### Main command execution loop for the monitor.
<div class="tooltip_code" onclick="loadDisasmCode('disasm\\disasm-B08B.html');">Disassembled code</div>
Clears a line for input, then gets a command line into the input buffer
([$0200-$02A0](0200#0200)). The routine accepts characters until RETURN is
pressed. Characters are then retrieved
from the buffer until one is found that is not a space. This
character is assumed to be a monitor command (all monitor
commands consist of a single character). With this character in
the accumulator, the routine jumps through the IMON indirect
vector at [$032E-$032F](0300#032E). Normally, this vector points
to the jump table entry at [$B006](#B006), which immediately returns
to the address following the indirect jump. However, this
vector can be changed to allow additional commands to be added
to the monitor. See the discussion at IMON for more details.

The routine then compares the command character in the
accumulator against characters from the command table at
[$B0E6](#B0E6). If no match is found, an error is assumed, and
(at $B0BC) the error signal (a question mark) is printed following
the command. The routine then loops back to process another command.
If a match is found among the first 15 characters in the command
table, then the command is executed
by pushing an address from the table at [$B0FC](#B0FC) onto
the stack, then jumping to read the parameter following the
command. The RTS at the end of the parameter decoding routine
[$B7A7](#B7A7) will cause control to be passed to the command
execution address stored on the stack. If the matching
character is among characters 16-19 in the table ($-%), then a jump
is taken to the base conversion routine [$B9B1](#B9B1). If the
matching character is among characters 20-22 in the table (L-V),
then a jump is taken to the routine that prepares for load,
save, or verify [$B337](#B337).
