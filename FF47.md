---
layout: default
title: FF47 - Kernal
---
# $FF47-$FFF3

## 65351 $FF47 SPIN SPOUT <a name="FF47"></a>
The C128/1571 fast serial protocol utilizes CIA 1 (6526 at $DC00) and a special driver circuit controlled in part by the MMU (at $D500). SPINP and SPOUT are routines used by the system to set up the CIA and fast serial driver circuit for input or output. SPINP sets up CRA (CIA 1 register 14) and clears the FSDIR bit (MMU register 5) for input. SPOUT sets up CRA, ICR (CIA 1 register 13), timer A (CIA 1 registers 4 and 5), and sets the FSDIR bit for output. Note the state of the TODIN bit of CRA is always preserved, but the state of the GAME, EXROM and SENSE40 outputs of the MMU are not (reading these ports return the state of the port and not the register values consequently they cannot be preserved). These routines are required only by applications driving the fast serial bus themselves from the lowest level.

## 65354 $FF4A CLOSE ALL <a name="FF4A"></a>
The FAT is searched for the given FA. A proper CLOSE is performed for all matches. If one of the CLOSEd channels is the current I/O channel, then the default channel is restored. This call is utilized, for example, by the BASIC command DCLOSE. It is also called by the Kernal BOOT routine.

## 65357 $FF4D C64MODE <a name="FF4D"></a>
There is no return from this routine. The 8502 DDR and port are initialized, and the VIC is set to 1MHz (slow) mode. Control is passed to code in common (shared) RAM, which sets the MMU mode register (#5) to C64 mode. From this point on, the MMU and C128 ROMs are not accessible. The routine exits via an indirect jump through the C64 RESET vector.

Since C64 operation does not allow for MMU access, all MMU registers must be configured for proper operation before the C64 mode bit is set. Similarly, because the start-up of the C64 operating system is not from a true hardware reset, there is the possibility that unusual I/O states in effect prior to C64MODE calls can cause unpredictable and presumably undesirable situations once in C64 mode.

There is no way to switch from C64 mode back to C128 mode; only a hardware reset or power off/on will restore the C128 mode of operation. A reset will always initiate C128 mode, although altering the SYSTEM vector beforehand is one way to automatically "throw" a system back to C64 mode.

## 65360 $FF50 DMA CALL <a name="FF50"></a>
DMA CALL is designed to communicate with an external expansion cartridge capable of DMA and mapped into system memory at 102 ($DFxx). The DMA CALL converts the logical C128 bank parameter to MMU configuration via GETCFG, OR's in the I/O enable bit, and transfers control to RAM code at $03F0. Here the C128 bank specified is brought into context, and the user's command is issued to the DMA controller. The actual DMA transfer is performed at this point, with the 8502 kept off the bus in a wait state. As soon as the DMA controller releases the processor, memory is reconfigured to the state it was in at the time of the call and control is returned to the caller. The user must analyze the completion status by reading the DMA status register at $DF00.
Care should be taken in the utilization of the C128 RAM expansion product by any application using the built-in Kernal interface. This includes especially the use of the C128 BASIC commands FETCH, STASH and SWAP. In the routine that prepares a DMA request for the user, the Kernal forces the I/O block to be always in context. Consequently, data from the DMA device is likely to corrupt sensitive I/O devices. Users should either bypass the Kernal DMA routine by providing their own interface, or limit the DMA data transfers to the areas above and below the I/O block. Only strict observance of the latter will guarantee proper utilization of the BASIC commands. The following code, used instead of the DMA CALL in the above example, illustrates a work-around:

```Assembly
  LDX	#$00	// C128 bank
  LDY	#$84	// DMA command to "STASH"
  JSR	$FF6B	// GETCFG
  TAX
  JSR	$3F0	// execute DMA command
```

### Example

```Assembly
  LDA	#$00	// setup C128 base address
  STA	$DF02	// low
  LDA	#$20
  STA	$DF03	// high

  LDA	#$00	// setup expansion RAM address
  STA	$DF04	// low
  STA	$DF05	// high
  STA	$DF06	// bank (0-n, where n = 3 if 256K)

  LDA	#$40	// setup number of bytes
  STA	$DF07	// low
  LDA	#$1F
  STA	$DF08	// high

  LDX	#$00	// C128 bank
  LDY	#$84	// DMA command to "STASH"
  JSR	$FF50	// execute DMA command
```

## 65363 $FF53 BOOT CALL <a name="FF53"></a>
BOOT CALL attempts to load and execute the boot sector from an auto-boot disk in the given drive and device. The BOOT protocol is as follows:

* Close all open files on boot device.
* Read track 1 sector 0 into TBUFFR ($B00).
* Check for auto-boot header, RTS if not.
* If (blk# > 0), BLOCK READ sequential sectors into RAM at given (adrl, adrh, bank) location.
* If LEN(filename) > 0, LOAD file into RAM-0 (normal load).
* JSR to user code at location C above.

On any error, the BOOT operation is aborted and the UI command is issued to the disk. A return may or may not be made to the caller depending upon the completion status and the BOOTed code. The BOOT sector has the following layout:

|$00|$01|$02|$03|$04|$05|$06||A||B|C|
|-|-|-|-|-|-|-|-|-|-|-|-|
|C|B|M|adrl|adrh|bank|blk#|title|0|file|0|code|

<pre>
where: A = $07 + LEN(title)
       B =   A + LEN(filename)
       C =   B + 1
</pre>

The following examples illustrate the flexibility of this layout. This loads and runs a BASIC program:
<pre>
$00	->	CBM	:key
$03	->	$00,$00,$00,$00	:no other BOOT sector
$07	->	NAME,$00	:message "NAME"
$0C	->	$00	:no filename
$0D	->	$A2,$13,$A0,$0B
$4C,$A5,$AF	:code
$14	->	RUN"PROGRAM"	:data (BASIC stmt)
$20	->	$00	
</pre>
This results in the message Booting NAME... being displayed and, utilizing a C128 BASIC jump table entry that finds and executes a BASIC statement, loads and runs the BASIC program named " P R O G R A M . " The same header can be used to load and execute a binary (machine code) program by simply changing RUN to BOOT. (While the file auto-load feature of the boot header could be used to load binary files simply by furnishing a filename, to execute it you must know the starting address and JMP to it. BASIC's BOOT command does that, and allows a more generic mechanism.) In the next example, a menu is displayed and you are asked to select the operating mode. Nothing else is loaded in this "configure"-type header:
<pre>
$00	->	CBM	:key
$03	->	$00,$00,$00,$00	:no other BOOT sector
$07	->	$00	:no message
$0C	->	$00	:no filename
$0D	->	$20,$7D, $FF,$0D, $53, $45,$4C, $45
$43, $54, $20,$4D, $4F, $44, $45,$3A
$0D,$0D, $20, $31,$2E, $20, $43, $36
$34, $20, $20, $42, $41, $53, $49, $43
$0D, $20, $32,$2E, $20, $43, $31, $32
$38, $20, $42, $41, $53, $49, $43,$0D
$20, $33,$2E, $20, $43, $31, $32, $38
$20,$4D, $4F, $4E, $49, $54, $4F, $52
$0D,$0D, $00, $20,$E4,$FF,$C9, $31
$D0, $03,$4C,$4D,$FF,$C9, $32,$D0
$03,$4C, $03, $40,$C9, $33,$DO, $E3
$4C, $00,$B0	
</pre>
The loading of sequential sectors is designed primarily for specialized applications (such as CP/M or games) that do not need a disk directory entry.

## 65366 $FF56 PHOENIX <a name="FF56"></a>
The C128 Kernal initialization routine POLL creates a Physical Address Table (PAT) containing the ID's of all installed function ROM cartridges. PHOENIX calls each logged cartridge's cold-start entry in the order: external low/high, and internal low/high. After calling the cartridges (if any), PHOENIX calls the Kernal BOOT routine to look for an auto-boot disk in drive 0 of device 8 (see BOOT CALL). Control may or may not be returned to the user. PHOENIX is called by BASIC at the conclusion of its cold initialization.

## 65369 $FF59 LKUPLA <a name="FF59"></a>
LKUPLA is a Kernal routine used primarily by BASIC DOS commands to work around a user's open disk channels. The Kernal requires unique logical device numbers (LA's), and the disk requires unique secondary addresses (SA's); therefore BASIC must find alternative unused values whenever it needs to establish a disk channel.

## 65372 $FF5C LKUPSA <a name="FF5C"></a>
LKUPSA is a Kernal routine used primarily by BASIC DOS commands to work around a user's open disk channels. The Kernal requires unique logical device numbers (LA's), and the disk requires unique secondary addresses (SA's); therefore BASIC must find alternative unused values whenever it needs to establish a disk channel.

## 65375 $FF5F SWAPPER <a name="FF5F"></a>
SWAPPER is an Editor utility used to switch between the 40-column VIC (composite) video display and the 80-column 8563 (RGBI) video display. The routine simply swaps local (associated with a particular screen) variables, TAB tables and line wrap maps with those describing the other screen. The MSB of MODE, location $D7, is toggled by SWAPPER to indicate the current display mode: $80= 80-column, $00= 40-column.

## 65378 $FF62 DLCHR <a name="FF62"></a>
DLCHR (alias INIT80) is an Editor utility to copy the VIC character definitions from ROM ($D000-$DFFF, bank 14) to 8563 display RAM ($2000-$3FFF, local to 8563-not in processor address space). The 8 by 8 VIC character cells are padded with nulls ($00) to fill out the 8 by 16 8563 character cells. Refer to Chapter 10 in Commodore 128 Programmers Reference Guide, Programming the 80-Column (8563) Chip for details concerning the 8563 font layout.

## 65381 $FF65 PFKEY <a name="FF65"></a>
PFKEY (alias KEYSET) is an Editor utility to replace a C128 function key string with a user's string. Keys 1-8 are F1-F8, 9 is the SHIFT RUN string, and 10 is the HELP string. The example below replaces the "help" RETURN string assigned at system initialization to the H E L P key with the string "string." Both the key length table, PKYBUF ($1000-$1009), and the definition area, PKYDEF ($100A-$10FF) are compressed and updated. The maximum length of all ten strings is 246 characters. No change is made if there is insufficient room for a new definition.

## 65384 $FF68 SETBNK <a name="FF68"></a>
SETBNK is a prerequisite for any memory I/O operations, and must be used along with SETLFS and SETNAM prior to OPENing files, etc. BA ([198/$C6](0000#C6)) sets the current 64KB memory bank for LOAD/SAVE/VERIFY operations. FNBANK ([199/$C7](0000#C7)) indicates the bank in which the filename string is found. The Kernal routine GETCFG is used to translate the given logical bank numbers (0-15). SETBNK is often used along with SETNAM and SETLFS calls prior to OPEN's. See the Kernal OPEN, LOAD and SAVE calls for examples.

## 65387 $FF6B GETCFG <a name="FF6B"></a>
GETCFG allows a universal, logical approach to physical bank numbers by providing a simple lookup conversion for obtaining the actual MMU configuration data. In all cases where a bank number 0-15 is required, you can expect GETCFG to be called to convert that number accordingly. There is no error checking; if the given logical bank number is out of range the result is invalid. Refer to the Memory Management Unit in the Commodore 128 section later in this chapter for details concerning memory configuration. The C128 Kernal memory banks are assigned as follows:
|Bank|Value|Description|
|-|-|-|
|0|%00111111|RAM 0 only|
|1|%01111111|RAM 1 only|
|2|%10111111|RAM 2 only|
|3|%11111111|RAM 3 only|
|4|%00010110|INT ROM, RAM 0, I/O|
|5|%01010110|INT ROM, RAM 1, I/O|
|6|%10010110|INT ROM, RAM 2, I/O|
|7|%11010110|INT ROM, RAM 3, I/O|
|8|%00101010|EXT ROM, RAM 0, I/O|
|9|%01101010|EXT ROM, RAM 1, I/O|
|10|%10101010|EXT ROM, RAM 2, I/O|
|11|%11101010|EXT ROM, RAM 3, I/O|
|12|%00000110|KERNAL, INT LO, RAM 0, I/O|
|13|%00001010|KERNAL, EXT LO, RAM 0, I/O|
|14|%00000001|KERNAL, BASIC, RAM 0, CHAR ROM|
|15|%00000000|KERNAL, BASIC, RAM 0, I/O|

## 65390 $FF6E JSRFAR <a name="FF6E"></a>
The routine JSRFAR, enable code executing in the system bank of memory to call a routine in any other bank. In the case of JSRFAR, a return will be made to the caller's bank. It should be noted that JSRFAR calls JMPFAR, which calls GETCFG. When calling a non-system bank, the user should take necessary precautions to ensure that interrupts (IRQ's and NMI's) will be handled properly (or disabled beforehand). Both JSRFAR and JMPFAR are RAM-based routines located in common (shared) RAM at $2CD and $2E3 respectively.

The following code illustrates how to call a subroutine in the second RAM bank from the system bank. Note that we need not worry about IRQ's and NMI's in this case because the system will handle them properly in any configuration that has the Kernal ROM or any valid RAM bank in context at the top page of memory.

### Example
```Assebmly
  STY	$08	  // assumes registers and status
  STX	$07	  // already setup for call
  STA	$06
  PHP
  PLA
  STA	$05
  
  LDA	#1	  // want to call $2000 in bank 1
  LDY	#$20
  LDX	#$00
  STA	$02
  STY	$03
  STX	$04

  JSR	$FF6E // JSRFAR

  LDA	$05	  // restore status and registers
  PHA
  LDA	$06
  LDX	$07
  LDY	$08
  PLP
```

## 65393 $FF71 JMPFAR <a name="FF71"></a>
The routine JMPFAR, enable code executing in the system bank of memory to JMP to a routine in any other bank. It should be noted that JSRFAR calls JMPFAR, which calls GETCFG. When calling a non-system bank, the user should take necessary precautions to ensure that interrupts (IRQ's and NMI's) will be handled properly (or disabled beforehand). Both JSRFAR and JMPFAR are RAM-based routines located in common (shared) RAM at $2CD and $2E3 respectively.

The following code illustrates how to call a subroutine in the second RAM bank from the system bank. Note that we need not worry about IRQ's and NMI's in this case because the system will handle them properly in any configuration that has the Kernal ROM or any valid RAM bank in context at the top page of memory.

### Example
```Assebmly
  STY	$08	  // assumes registers and status
  STX	$07	  // already setup for call
  STA	$06
  PHP
  PLA
  STA	$05
  
  LDA	#1	  // want to call $2000 in bank 1
  LDY	#$20
  LDX	#$00
  STA	$02
  STY	$03
  STX	$04

  JSR	$FF6E // JSRFAR

  LDA	$05	  // restore status and registers
  PHA
  LDA	$06
  LDX	$07
  LDY	$08
  PLP
```

## 65396 $FF74 INDFET <a name="FF74"></a>
INDFET enables applications to read data from any other bank. It sets up FETVEC ($2AA), calls GETCFG to convert the bank number, and JMPs to code in common (shared) RAM at $2A2 which switches banks, loads the data, restores the user's bank, and returns. When calling a non-system bank, the user should take necessary precautions to ensure that interrupts (IRQ's and NMI's) will be handled properly (or disabled beforehand).

### Example

```Assembly
  LDA #$00    // setup to read $2000
  STA $FA
  LDA #$20
  STA $FB
  LDA #$FA
  LDX #$01    // in bank 1
  LDY #$00
  JSR $FF74   // LDA ($FA,RAM 1),Y
  BEQ etc
```

## 65399 $FF77 INDSTA <a name="FF77"></a>
INDSTA enables applications to write data to any other bank. After you set up STAVEC ($2B9), it calls GETCFG to convert the bank number and JMPs to code in common (shared) RAM at $2AF which switches banks, stores the data, restores your bank, and returns. When calling a nonsystem bank, the user should take necessary precautions to ensure that interrupts (IRQ's and NMI's) will be handled properly (or disabled beforehand).

### Example

```Assembly
  LDA #$00      // setup write to $2000
  STA $FA
  LDA #$20
  STA $FB
  LDA #$FA
  STA $2B9
  LDA data
  LDX #$01      // in bank 1
  LDY #$00
  JSR $FF77     // STA ($FA,RAM 1),Y
```

## 65402 $FF7A INDCMP <a name="FF7A"></a>
INDCMP enables applications to compare data to any other bank. After you set up CMPVEC ($2C8), it calls GETCFG to convert the bank number and JMP's to code in common (shared) RAM at $2BE which switches banks, compares the data, restores your bank, and returns. When calling a nonsystem bank, the user should take necessary precautions to ensure that interrupts (IRQ's and NMI's) will be handled properly (or disabled beforehand).

### Example

```Assembly
  LDA #$00    // setup to verify $2000
  STA $FA
  LDA #$20
  STA $FB
  LDA #$FA
  STA $2C3
  LDA data
  LDX #$01    // in bank 1
  LDY #$00
  JSR $FF7A   // CMP ($FA,RAM 1),Y
  BEQ same
```

## 65405 $FF7D PRIMM <a name="FF7D"></a>
PRIMM is a Kernal utility used to print (to the default output device) an ASCII string which immediately follows the call. The string must be no longer than 255 characters and is terminated by a null ($00) character. It cannot contain any embedded null characters. Because PRIMM uses the system stack to find the string and a return address, you must not JMP to PRIMM. There must be a valid address on the stack.

## 65409 $FF81 CINT <a name="FF81"></a>
CINT is the Editor's initialization routine. Both 40- and 80-column display modes are prepared, editor indirect vectors installed, programmable key definitions asigned, and the 40/80 key scanned for default display determination. CINT sets the VIC bank and VIC nybble bank, enables the character ROM, resets SID volume, places both 40- and 80-column screens and clears them. The only thing it does not do that pertains to the Editor is I/O initialization, which is needed for IRQ's (keyscan, VIC cursor blink, split screen modes), key lines, screen background colors, etc. (see IOINIT). Because CINT updates Editor indirect vectors that are used during IRQ processing, you should disable IRQ's prior to callint it. CINT utilizes the status byte INIT_STATUS ($A04) as follows:
<pre>
$A04 bit 6 = 0 -> Full initialization. (set INIT_STATUS bit 6)
             1 -> Partial initialization. (not key matrix pointers) and (not program key definitions)
</pre>
CINT is also an Editor jump table entry ($C00).

## 65412 $FF84 IOINIT <a name="FF84"></a>
IOINIT is perhaps the major function of the Reset handler. It initializes both CIA's (timers, keyboard, serial port, user port, cassette) and the 8502 port (keyboard, cassette, VIC bank). It distinguishes a PAL system from and NTSC one and sets PALCNT ($0A03) if PAL. The VIC, SID and 8563 devices are initialized, including the downloading of character definitions to 8563 display RAM (if necessary). The system 60Hz IRQ source, the VIC raster, is started (pending IRQs are cleared). IOINIT utilizes the status byte INIT_STATUS ($0A04) as follows:
<pre>
$A04 bit 7 = 0 -> Full initialization (set INIT_STATUS bit 7)
             1 -> Partial initialization. (not 8563 character definitions)
</pre>
You should be sure IRQ's are disabled before calling IOINIT to avoid interrupts while the various I/O devices are bing initialized.

## 65415 $FF87 RAMTAS <a name="FF87"></a>
RAMTAS clears all page-zero RAM, allocates the cassette and RS-232 buffers, sets pointers to the top and bottom of system RAM (RAM 0) and points the SYSTEM_VECTOR ($0A00) to BASIC cold start ($4000). Finally, it sets a flag, DEJAVU ($0A02), to indicate to other routines that system RAM has been initialized and that the SYSTEM_VECTOR is valid. It should be noted that the C128 RAMTAS routine does not in any way test RAM.

## 65418 $FF8A RESTOR <a name="FF8A"></a>
RESTOR restores the default values of all the Kernal indirect vectors from the Kernal ROM list. It does not affect any other vectors, such as those used by the Editor (see CINT) and BASIC. Because it is possible for an interrupt (IRQ or NMI) to occur during the updating of the interrupt indirect vectors, you should disable interrupts prior to calling RESTOR. Seee also the VECTOR call.

## 65421 $FF8D VECTOR <a name="FF8D"></a>
VECTOR reads or writes the Kernal RAM indirect vectors. Calling VECTOR with the carry status set stores the current contents of the indirect vectors to the RAM address passed in the X and Y registers (to the current RAM bank). Calling VECTOR with the carry status clear updates the Kernal indirect vectors from the user list passed in the X and Y registers (from the current RAM bank). Interrupts (IRQ and NMI) should be disabled when updating the indirects. See also the RESTOR call.

## 65424 $FF90 SETMSG <a name="FF90"></a>
SETMSG updates the Kernal message flag byte MSGFLG ([157/$9D](0000#9D)) that determines whether system error and/or control messages will be displayed. BASIC normally disables error messages always and disables control messages in Run mode. Note that the Kernal error messages are not the verbose ones printed by BASIC, but simply the I/O ERROR # message that you see when in the Monitor, for example. Examples of Kernal control messages are LOADING, FOUND, and PRESS PLAY ON TAPE. The MSGFLG control bits are:
<pre>
MSGFLG bit 7 = 1 -> enable CONTROL messages
       bit 6 = 1 -> enable ERROR messages
</pre>

## 65427 $FF93 SECOND <a name="FF93"></a>
SECOND is a low-level serial routine used to send a secondary address (SA) to a LISTENing device (see LISTEN Kernal call). An SA is usually used to provide setup information to a device before the actual data I/O operation begins. Attention is released after a call to SECOND. SECOND is not used to send an SA to a TALKing device (see TKSA). (Most applications should use the higher level I/O routines: see OPEN and CHKOUT).

## 65430 $FF96 TKSA <a name="FF96"></a>
TKSA is a low-level serial routine used to send a secondary address (SA) to a device commanded to TALK (see TALK Kernal call). An SA is usually used to provide setup information to a device before the actual data I/O operation begins. (Most applications should use the higher-level I/O routines; see OPEN and CHKIN).

## 65433 $FF99 MEMTOP <a name="FF99"></a>
MEMTOP is used to read or set the top of system RAM, pointed to by MEMSIZE ($0A07). This call is included in the C128 for completeness, but neither the Kernal nor BASIC utilizes MEMTOP since it has little meaning in the banked memory environment of the C128 (even the RS-232 buffers are permanently allocated). Nonetheless, set the carry status to load MEMSIZE into X and Y, and clear it to update the pointer from X and Y. Note that MEMSIZE references only system RAM (RAM0). The Kernal initially sets MEMSIZE to $FF00 (MMU and Kernal RAM code start here).

## 65436 $FF9C MEMBOT <a name="FF9C"></a>
MEMBOT is used to read or set the bottom of system RAM, pointed to by MEMSTR ($0A05). This call is included in the C128 for completeness, but neither the Kernal nor BASIC utilizes MEMBOT since it has little meaning in the backed memory environment of the C128. Nonetheless, set the carry status to load MEMSTR into X and Y, and clear it to update the pointer from X and Y. Note that MEMSTR references only system RAM (RAM0). The Kernal initially sets MEMSTR to $1000 (BASIC text starts here).

## 65439 $FF9F SCNKEY <a name="FF9F"></a>
SCNKEY is an Editor routine that scans the entire C128 keyboard (except the 40/80 key). It distinguishes between ASCII keys, control keys, and programmable keys, setting keyboard status bytes and managing the keyboard buffer. After decoding the key, SCNKEY will manage such features as toggling cases, pauses or delays, and key repeats. It is normally called by the operating system during the 60Hz IRQ processing. Upon conclusion, SCNKEY leaves the keyboard hardware driving the keyline on which the STOP key is located.

There are two indirect RAM jumps encountered during a keyscan: KEYVEC ($033A) and KEYCHK ($033C). KEYVEC (alias KEYLOG) is taken whenever a key depression is discovered, before the key in A has been decoded. KEYCHK is taken after the key has been decoded, just before putting it into the key buffer. KEYCHK carries the ASCII character in A, the keycode in Y, and the skiftkey status in X.

The keyboard decode matrices are addressed via indirect RAM vectors as well, located at DECODE ($33E).

The following table describes them:
<pre>
$33E	Mode 1	->	normal keys
$340	Mode 2	->	SHIFT keys
$342	Mode 3	->	C= keys
$344	Mode 4	->	CONTROL keys
$346	Mode 5	->	CAPS LOCK keys
$348	Mode 6	->	ALT keys
</pre>
The following list briefly describes some of the more vital variables utilized or maintained by SCNKEY:
<pre>
ROWS    $DC01 ->  I/O port outputting keys
COLM    $DC00 ->  I/O port driving C64 keys
VIC #47 $D02F ->  I/O port driving new keys
8502 P6 $0001 ->  I/O port sensing CAPS key
NDX     $D0   ->  keyboard buffer index
KEYD    $34A  ->  keyboard buffer
XMAX    $A20  ->  keyboard buffer size
SHFLAG  $D3   ->  shift key status
RPTFLG  $A22  ->  repeat key enables
LOCKS   $F7   ->  pause, mode disables
</pre>

SCNKEY is also found in the Editor jump table at $C012.

## 65442 $FFA2 SETTMO <a name="FFA2"></a>
SETTMO is not used in the C128 but is included for compatibility and completeness. It is used in the C64 by the IEEE communication cartridge to disable I/O timeouts.

## 65445 $FFA5 ACPTR <a name="FFA5"></a>
ACPTR is a low-level serial I/O utility to accept a single byte from the current serial bus TALKer using full handshaking. To prepare for this routine, a device must first have been established as a TALKer (see [TALK](#FFB4)) and passed a secondary address if necessary (see [TKSA](#FF96)). The byte is returned in A. Most applications should use the higher-level I/O routines; see BASIN and GETIN.

## 65448 $FFA8 CIOUT <a name="FFA8"></a>
CIOUT is a low-level serial I/O utility to transmit a single byte to the current serial bus LISTENer using full handshaking. To prepare for this routine, a device must first have been established as a LISTENer (see [LISTEN](#FFB4)) and passed a secondary address if necessary (see [SECOND](#FF93)). The byte is passed in A. Serial output data is buffered by one character, with the last character being transmitted with EOI after a call to [UNLSN](#FFAE). Most applications should use the higher level I/O routines; see BSOUT.

## 65451 $FFAB UNTLK <a name="FFAB"></a>
UNTLK is a low-level Kernal serial bus routine that sends and UNTALK command to all serial bus devices. It commands all TALKing devices to sop sending data. (Most applications should us the higher-level I/O routines; see CLRCHN).

## 65454 $FFAE UNLSN <a name="FFAE"></a>
UNLSN is a low-level Kernal serial bus routine that sends an UNLISTEN command to all serial bus devices. It commands all LISTENing devices to stop reading data. (Most applications should us the higher-level I/O routines; see CLRCHN)

## 65457 $FFB1 LISTEN <a name="FFB1"></a>
LISTEN is a low-level Kernal serial bus routine that sends a LISTEN command to the serial bus device in A. It commands the device to start reading data. Most applications should use the higher-level I/O routines; see CHKOUT.

## 65460 $FFB4 TALK <a name="FFB4"></a>
TALK is a low-level Kernal serial bus routine that sends a TALK command to the serial bus device in A. It commands the device to start sending data. (Most applications should use the higher-level I/O routines; see CHKIN.)

## 65463 $FFB7 READST <a name="FFB7"></a>
READST (alias READSS) returns the status byte associated with the last I/O operation (serial, cassette or RS-232) performed. Serial and cassette tape operations update STATUS ([144/$90](0000#90)) and RS-232 I/O updates RSSTAT ($0A14). Note that to simulate an ACIA, RSSTAT is cleared after it is read via READST. The last I/O operation is determined by the contents of FA ([186/$BA](0000#BA)); thus applications that drive I/O devices using the lower-level Kernal calls should not use READST.

## 65466 $FFBA SETLFS <a name="FFBA"></a>
SETLFS sets the logical file number (LA, [184/$B8](0000#B8)), device number (FA, [186/$BA](0000#BA)) and secondary address (SA, [185/$B9](0000#B9)) for the higher-level Kernal I/O routines. The LA must be unique among OPENed files and is used to identify specific files for I/O operations. The device number rangs is 0 to 31 and is used to target I/O. The SA is a command to be sent to the indicated device, usually to place it in a particular mode. If the SA is not needed, the Y register should pass $FF. SETLFS is often used along with SETNAM and SETBNK calls prior to OPENs. See the Kernal OPEN, LOAD and SAVE calls for examples.

## 65466 $FFBD SETNAM <a name="FFBd"></a>
SETNAM sets up the filename or command string for higher-level Kernal I/O calls such as OPEN, LOAD and SAVE. The string (filename or command) length is passed in A and updates FNLEN ([183/$B7](0000#B7)). The address of the string is passed in X (low) and Y (high). See the companion call, SETBNK, which specifies in which RAM bank the string is found. If there is no string, SETNAM should still be called and a null ($00) length specified (the address does not matter). SETNAM is often used along with SETBNK and SETLFS calls prior to OPENs. See the Kernal OPEN, LOAD and SAVE calls for examples.

## 65472 $FFC0 OPEN <a name="FFC0"></a>
OPEN prepares a logical file for I/O operations. It creates a unique entry in the Kernal logical file tables LAT ($0362), FAT ($036C) and SAT ($0376) using its index LDTND ([152/$98](0000#98)) and data supplied by the user via SETLFS. There can be up to then logical files OPENed simultaneously. OPEN performs device-specific opening tasks for serial, cassette and RS-232 devices, including clearing the previous status and transmitting any given filename or command string supplied by the user via SETNAM and SETBNK. The I/O status is updated appropriately and can be read via READST.

The path to OPEN is through an indirect RAM vector at $031A. Applications may therefor provide their own OPEN procedures or supplement the system's by redirecting this vector to their own routine.

## 65475 $FFC3 CLOSE <a name="FFC3"></a>
CLOSE removes the logical file (LA) passed in A from the logical file tables and performs device-specific closing tasks. Keyboard, screen and any unOPENed files pass through. Cassette files opened for output are closed by writing the last buffer and (optionally) an EOT mark. RS-232 I/O devices are reset, losing any buffered data. Serial files are closed by transmitting a CLOSE command (if an SA was given when it was opened), sending any buffered character, and UNLSNing the bus.
There is a special provision incorporated into the CLOSE routine of systems featuring a BASIC DOS command. If the following conditions are all true, a full CLOSE is not performed; the table entry is removed but a CLOSE command is not transmitted to the device. This allows the disk command channel to be properly OPENed and CLOSEd without the disk operating system closing all files on its end:
<pre>
.C = 1	->	indicates special CLOSE
FA >= 8	->	device is a disk
SA = 15	->	command channel
</pre>
The path to CLOSE is through an indirect RAM vector at $031C. Applications may therefor provide their own CLOSE procedure or supplement the system's by redirecting this vector to their own routine.

## 65478 $FFC6 CHKIN <a name="FFC6"></a>
CHKIN establishes an input channel to the device associated with the logical address (LA) passed in X, in preparation for at call to BASIN or GETIN. The Kernal variable DFLTN ([153/$99](0000#99)) is updated to indicate the current input device and the variables LA, FA and SA are updated with the file's parameters from its entry in the logical file tables (put there by OPEN). CHKIN performs certain device specific tasks: screen and keyboard channels pass through, cassette files are confirmed for input, and serial channels are sent a TALK command and the SA transmitted (if necessary). Call CLRCHN to restore normal I/O channels.

CHKIN is required for all input except the keyboard. If keyboard input is desired and no other input channel is established, you do not need to call CHKIN or OPEN. The keyboard is the default input device for BASIN and GETIN.

The path to CHKIN is through an indirect RAM vector at $031E. Applications may therefor provide their own CHKIN procedure or supplement the system's by redirecting this vector to their own routine.

## 65481 $FFC9 CHKOUT <a name="FFC6"></a>
CHKOUT establishes an output channel to the device associated with the logical address (LA) passed in X, in preparation for a call to BSOUT. The Kernal variable DFLTO [154/$9A](0000#9A) is updated to indicate the current output device and the variables LA, FA and SA are updated with the file's parameters from its entry in the logical file tables (put there by OPEN). CKOUT performs certain device specific tasks: keyboard channels are illegal, screen channels pass through, cassette files are confirmed for output, and serial channels are sent a LISTN command and the SA transmitted (if necessary). Call CLRCH to restore normal I/O channels.

CKOUT is required for all output except the screen. If screen output is desired and no other output channel is established, you do not need to call CKOUT or OPEN. The screen is the default output device for BSOUT.

The path to CKOUT is through an indirect RAM vector at $0320. Applications may therefore provide their own CKOUT procedures or supplement the system's by redirecting this vector to their own routine.

## 65484 $FFCC CLRCHN <a name="FFCC"></a>
CLRCHN (alias CLRCH) is used to clear all open channels and restore the system default I/O channels after other channels have been established via CHKIN and/or CHKOUT. The keyboard is the default input device and the screen is the default output device. If the input channel was to a serial device, CLRCH first UNTLKs it. If the output channel was to a serial device, it is UNLSNed first.

The path to CLRCH is through an indirect RAM vector at $0322. Applications may therefore provide their own CLRCH procedures or supplement the system's by redirecting this vector to their own routine.

## 65487 $FFCF CHRIN/BASIN <a name="FFCF"></a>
CHRIN (alias BASIN) reads a character from the current input device (DFLTN [153/$99](0000#99)) and returns it in A. Input from devices other than the keyboard (the default input device) must be OPENed and CHKINed. The character is read from the input buffer associated with the current input channel:

* Cassette data is returned a character at a time from the cassette buffer at $0B00, with additional tape blocks being read when necessary.
* RS-232 data is returned a character at a time from the RS-232 input buffer at $0C00, waiting until a character is received if necessary. If RSSTAT ($0A14) is bad from a prior operation, input is skipped and null input (carriage return) is substituted.
* Serial data is returned a character at a time directly from the serial bus, waiting until a character is sent if necessary. If STATUS ([144/$90](0000#90)) is bad from a prior operation, input is skipped and null input (carriage return) is substituted.
* Screen data is read from screen RAM starting at the current cursor position and ending with a pseudo carriage return at the end of the logical screen line. The way the BASIN routine is written, the end of line (EOL) is not recog- nized. Users must therefore count characters themselves or otherwise detect when the logical EOL has been reached.
* Keyboard data is input by turning on the cursor, reading characters from the keyboard buffer, and echoing them on the screen until a carriage return is encountered. Characters are then returned one at a time from the screen until all characters input have been passed, including the carriage return. Any calls after the EOL will start the process over again.

The path to CHKIN is through an indirect RAM vector at $0324. Applications may therefore provide their own BASIN procedures or supplement the system's by redirecting this vector to their own routine.

## 65490 $FFD2 CHROUT/BSOUT <a name="FFD2"></a>
CHROUT (alias BSOUT) writes the character in A to the current output device (DFLTO [154/$9A](0000#9A)). Output to devices other than the screen (the default output device) must be OPENed and CKOUTed. The character is written to the output buffer associated with the current output channel:

* Cassette data is put a character at a time into the cassette buffer at $0B00, with tape blocks being written when necessary.
* RS-232 data is put a character at a time into the RS-232 output buffer at $0D00, waiting until there is room if necessary.
* Serial data is passed to CIOUT, which buffers one character and sends the previous character.
* Screen data is put into screen RAM at the current cursor position.
* Keyboard output is illegal.

The path to CHROUT is through an indirect RAM vector at $0326. Applications may therefore provide their own CHROUT procedures or supplement the system's by redirecting this vector to their own routine.

## 65493 $FFD5 LOAD <a name="FFD5"></a>
This routine LOADs data from an input device into C128 memory. It can also be used to VERIFY that data in memory matches that in a file. LOAD performs device-specific tasks for serial and cassette LOADs. You cannot LOAD from RS-232 devices, the screen or the keyboard. While LOAD performs all the tasks of an OPEN, it does not create any logical files as an OPEN does. Also note that LOAD cannot "wrap" memory banks. As with any FO, the I/O status is updated appropriately and can be read via READSS. LOAD has two options that the user must select:

* LOAD vs. VERIFY: The contents of A passed at the call to LOAD determines which mode is in effect. If A is zero, a LOAD operation will be performed and memory will be overwritten. If A is nonzero, a VERIFY operation will be performed and the result passed via the error mechanism.
* LOAD ADDRESS: the secondary address (SA) setup by the call to SETLFS determines where the LOAD starting address comes from. If the SA is zero, the user wants the address in X and Y at the time of the call to be used. If the SA is nonzero, the LOAD starting address is read from the file header itself and the file is loaded into the same place from which it was SAVEd.

The C128 serial LOAD routine automatically attempts to BURST load a file, and resorts to the normal load mechanism (but still using the FAST serial routines) if the BURST handshake is not returned.

The path to LOAD is through an indirect RAM vector at $0330. Applications may therefore provide their own LOAD procedures or supplement the system procedures by redirecting this vector to their own routine.

### Example
```Assembly
  LDA	#length       // fnlen
  LDX	#filename
  JSR	$FFBD         // SETNAM

  LDA	#0            // load/verify bank (RAM0)
  LDX	#0            // fnbank (RAM0)
  JSR	$FF68         // SETBNK

  LDA	#0            // la (not used)
  LDX	#8            // fa
  LDY	#$FF          // sa (SA>0 normal load)
  JSR	$FFBA         // SETLFS

  LDA	#0            //  load, not verify
  LDX	#<load adr    // (used only if SA = 0)
  LDY	#>load adr    // (used only if SA = 0)
  JSR	$FFD5         // LOAD
  BCS	error
  STX	end_lo
  STY	end_hi
```

## 65496 $FFD8 SAVE <a name="FFD8"></a>
This routine SAVEs data from C128 memory to an output device. SAVE per- forms device-specific tasks for serial and cassette SAVEs. You cannot SAVE from RS-232 devices, the screen or the keyboard. While SAVE performs all the tasks of an OPEN, it does not create any logical files as an OPEN does. The starting address of the area to be SAVEd must be placed in a zero-page vector and the address of this vector passed to SAVE in A at the time of the call. The address of the last byte to be SAVEd PLUS ONE is passed in X and Y at the same time. Cassette SAVEs utilize the secondary address (SA) to specify the type of tape header(s) to be generated:
<pre>
SA (bit 0) = 0 -> relocatable  (blf) file
           = 1 -> absolute     (plf) file
SA (bit 1) = 0 -> normal end
           = 1 -> write EOT header at end
</pre>
There is no BURST save; the normal FAST serial routines are used. As with any I/O, the I/O status will be updated appropriately and can be read via READST.

The path to SAVE is through an indirect RAM vector at $0332. Applications may therefore provide their own SAVE procedures or supplement the system's by redirecting this vector to their own routine.

### Example

```
// SAVE "program",8
  LDA #length     // fnlen
  LDX #<filename  // fnadr
  LDY #>filename
  JSR $FFBD       // SETNAM

  LDA #0          // save from bank (RAM0)
  LDX #0          // fnbank (RAM0)
  JSR $FF68       // SETBNK

  LDA #0          // la (not used)
  LDX #8          // fa
  LDY #0          // sa (cassette only)
  JSR $FFBA       // SETLFS

  LDA #start      // pointer to start address
  LDX end         // ending address lo
  LDY end+1       // ending adr hi
  JSR $FFD8       // SAVE
  BCS error
filename  .BYTE "program
length    = 7
start     .WORD address1		// page-0
end       .WORD address2
```

## 65499 $FFDB SETTIM <a name="FFDB"></a>
SETTIM sets the system software (jiffie) clock, which counts sixtieths (1/60) of a second. The timer is incremented during system IRQ processing (see UDTIM), and reset at the 24-hour point. SETTIM disables IRQ's, updates the three-byte timer with the contents of A, X and Y, and re-enables IRQ's.

## 65502 $FFDE RDTIM <a name="FFDE"></a>
RDTIM reads the system software (jiffie) clock, which counts sixtieths (1/60) of a second. The timer is incremented during system IRQ processing (see UDTIM), and reset at the 24-hour point. RDTIM disables IRQ's, loads A, X and Y with the contents of the 3-byte timer, and re-enables IRQ's.

## 65505 $FFE1 STOP <a name="FFE1"></a>
STOP checks a Kernal variable STKEY ([145/$91](0000#91)), which is updated by UDTIM during normal IRQ processing and contains the last scan of keyboard column C7. The STOP key is bit 7, which will be 0 if the key is down. If it is, default I/O channels are restored via CLRCH and the keyboard queue is flushed by resetting NDX ($D0). The keys on keyboard line C7 are:

|Bit|7|6|5|4|3|2|1|0|
|-|-|-|-|-|-|-|-|-|
|Key|STOP|Q|C=|SPACE|2|CTRL|<-|1|

The path to STOP is through an indirect RAM vector at $0328. Applications may therefore provide their own STOP procedures or supplement the system's by redirecting this vector to their own routine.

## 65508 $FFE4 GETIN <a name="FFE4"></a>
GETIN reads a character from the current input device (DFLTN [153/$99](0000#99)) buffer and returns it in A. Input from devices other than the keyboard (the default input device) must be OPENed and CHKINed. The character is read from the input buffer associated with the current input channel:

* Keyboard input: A character is removed from the keyboard buffer and passed in A. If the buffer is empty, a null ($00) is returned.
* RS-232 input: A character is removed from the RS-232 input buffer at $0C00 and passed in A. If the buffer is empty, a null ($00) is returned (use READST to check validity).
* Serial input: GETIN automaticallyjumps to BASIN. See BASIN serial I/O.
* Cassette input: GETIN automatically jumps to BASIN. See BASIN cassette I/O.
* Screen input: GETIN automaticallyjumps to BASIN. See BASIN serial I/O.

The path to GETIN is through an indirect RAM vector at $032A. Applications may therefore provide their own GETIN procedures or supplement the system's by redirecting this vector to their own routine.

## 65514 $FFEA UDTIM <a name="FFEA"></a>
UDTIM increments the system software (jiffie) clock, which counts sixtieths (1/60) of a second when called by the system 60Hz IRQ. TIME, a 3-byte counter located at $A0, is reset at the 24-hour point. UDTIM also decrements TIMER, also a 3-byte counter, located at $AlD (BASIC uses this for the SLEEP command, for example). You should be sure IRQ's are disabled before calling UDTIM to prevent system calls to UDTIM while you are modifying TIME and TIMER. UDTIM also scans key line C7, on which the STOP key lies, and stores the result in STKEY ([145/$91](0000#91)). The Kernal routine STOP utilizes this variable.

## 65511 $FFE7 CLALL <a name="FFE7"></a>
CLALL deletes all logical file table entries by resetting the table index, LDTND ([152/$98](0000#98)). It clears current serial channels (if any) and restores the default I/O channels via CLRCHN. The path to CLALL is through an indirect RAM vector at $032C. Applications may therefore provide their own CLALL procedures or supplement the system's by redirecting this vector to their own routine.

## 65517 $FFED SCRORG <a name="FFED"></a>
SCRORG is an Editor routine that has been slightly changed from previous CBM systems. Instead of returning the maximum SCREEN dimensions in X and Y, the C128 SCRORG returns the current WINDOW dimensions. It does return the maximum SCREEN width in A. These changes make it possible for applications to "fit" themselves on the current screen window. SCRORG is also an Editor jump table entry ($C00F).

## 65520 $FFF0 PLOT <a name="FFF0"></a>
PLOT is an Editor routine that has been slightly changed from previous CBM systems. Instead of using absolute coordinates when referencing the cursor position, PLOT now uses relative coordinates, based upon the current screen window. The following local Editor variables are useful:

* SCBOT   $E4 -> window bottom
* SCTOP   $E5 -> window top
* SCLF    $E6 -> window left side
* SCRT    $E7 -> window right side
* TBLX    $EB -> cursor line
* PNTR    $EC -> cursor column
* LINES   $ED -> maximum screen height
* COLUMNS $EE -> maximum screen width

When called with the carry status set, PLOT returns the current cursor position relative to the current window origin (not screen origin). When called with the carry status clear, PLOT attempts to move the cursor to the indicated line and column relative to the current window origin (not screen origin). PLOT will return a clear carry status if the cursor was moved, and a set carry status if the requested position was outside the current window (no change has been made).

### Example
```Assembly
  SEC
  JSR $FFF0   // read current position
  INX         // move down one line
  INY         // move right one space
  CLC
  JSR $FFF0   // set cursor position
  BCS error   // new position outside window
```

## 65523 $FFF3 IOBASE <a name="FFF3"></a>
IOBASE is not used in the C128 but is included for compatibility and completeness. It returns the address of the I/O block in X and Y.
