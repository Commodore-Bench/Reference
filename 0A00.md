---
layout: default
title: $0A00-$0AFF - Kernal and Screen Editor Working Storage, Monitor Working Storage Area, Kernal Working Storage
---
# $0A00-$0AFF - Kernal and Screen Editor Working Storage, Monitor Working Storage Area, Kernal Working Storage

# Kernal and Screen Editor Working Storage ($0A00-$0A7F)

## 2560-2561 $0A00-$0A01 SYSTEM_VECTOR <a name="0A00"></a>
### BASIC restart vector
This pair of locations contains the address of the routine that
will be used to restart BASIC. The RAMTAS routine [$E093](E000#E093),
part of the reset sequence, puts the value $4000 here the address
of the BASIC cold start routine. Unless the Commodore or RUN/STOP keys
are held down, the RESET routine [$E000](E000) ends with a JMP ($0A00)
to cold start BASIC.
One of the final steps in the BASIC cold start routine is to
change the value here to $4003 - the address of the
BASIC warm start routine.

The RUN/STOP-RESTORE sequence in the NMI handling routine [$FA40](E000#FA40) ends
with a JMP ($0A00). Because of the
cold start's routine initialization, this will normally cause a
warm start of BASIC. However, you can make RUN/STOP-RESTORE cause a
jump to another routine by changing the
value in these locations to point to the address of the new
routine. The only restriction is that the target routine must be
visible in the bank 15 configuration, since that is how memory
is arranged when the IMP is executed.

The monitor X command routine [$B0E3](E000#B0E3) also performs a
IMP ($0A00), so the value in these locations determines the
address of the routine which will be executed when you use
that command to exit the built-in machine language monitor.

## 2562 $0A02 DEJAVU <a name="0A02"></a>
### Memory initialization status flag
This location is used to indicate whether the RAMTAS routine
has been performed. If the RESET routine [$E000](E000) detects that
the RUN/STOP key is being held down, indicating that the
reset sequence should end by entering the monitor rather than
BASIC, then the value here will be tested. If this location contains
the value 165/$A5, the RAMTAS routine will be omitted
from this reset sequence. The routine will hold a random
value when the computer is first turned on, but the first call of
the RAMTAS routine [$E093](E000#E093) will initialize this location to
165/$A5. Thus, once RAMTAS has been performed at least
once, the test of this flag location can be used to prevent its
being performed again when entering the monitor after a reset.
This allows you to preserve the contents of zero page,
normally cleared by RAMTAS during the reset.

## 2563 $0A03 PALNTS <a name="0A03"></a>
### PAL/NTSC flag
The IOINIT routine [$E109](E000#E109), part of the RESET sequence,
checks the number of scan lines produced by the VIC chip to
determine whether the 128 is using a NTSC (North American)
or PAL (European/British) video system. This location is set to
reflect the result of that test: to 0/$00 for NTSC systems or
255/$FF for PAL systems. Later routines that initialize the
video chips and timers can then adjust the default settings accordingly.
This eliminates the need for different versions of
the Kernal ROM for different countries.

## 2564 $0A04 INIT_STATUS <a name="0A04"></a>
### System initialization status flag
This location is initialized to 0/$00 near the beginning of the
Kernal RESET routine [$E000](E000). Bits are then set to %1 by later
routines to indicate that certain initialization steps have been
performed.

**Bit 0**: This bit is set to %1 during the BASIC cold start routine
[$4023](4000#4023) to indicate that the cold start has been performed. The
IRQ handling routine [$FA65](E000#FA65) checks this bit and calls the
BASIC IRQ routine [$A84D](4000#A84D) only if the bit is %1. The BASIC
IRQ routine, which handles sprite movement, sprite collision
detection, and sound generation, copies the contents of a number of
shadow locations into VIC and SID hardware registers.
One way to turn off this interrupt routine and gain direct access to
the hardware registers is to set this bit to %0.

**Bits 1-5**: Unused.

**Bit 6**: This bit is tested during the screen editor initialization
(CINT) routine [$C07B](C000#C07B) to determine whether the keyboard table pointers
and function key definitions need to be initialized.
If the bit is %0, the default pointer values and key definitions
will be copied from ROM into the proper areas of RAM; then
this bit will be set to %1. While this bit is %1, the pointer and
function key initialization portion of the routine will be skipped.
CINT is part of both the reset and RUN/STOP-RESTORE sequences, but the
pointers and key definitions are normally initialized only during the
reset sequence, which resets this bit to
%0 before calling CINT. Custom keyboard table pointers and
function key definitions are usually preserved during RUN/STOP-RESTORE,
which does not affect this bit.

**Bit 7**: This bit is tested during the IOINIT routine [$E109](E000#E109) to
determine whether the 80-column (VDC) character set needs
to be initialized. If the bit is %0, the INITSO routine [$CE0C](C000#CE0C)
will be called to copy the standard character patterns from
ROM into the VDC chip's private RAM; then this bit will be
set to %1. While this bit is %1, the character initialization portion
of the routine will be skipped. IOINT is part of both the
reset and RUN/STOP-RESTORE sequences, but the character
patterns are normally initialized only during the reset sequence,
which resets this bit to %0 before calling IOINT. Custom 80-column
characters are usually preserved during RUN/STOP-RESTORE, which does
not affect this bit.

## 2565-2566 $0A05-$0A06 MEMSTR <a name="0A05"></a>
### Kernal MEMBOT pointer
This pair of locations holds the default value of the lowest
memory address available in block 0 RAM. The value here can
be read or changed using the Kernal MEMBOT routine
[$F772](E000#F772), which has a Kernal jump table entry at 65436/$FF9C.
The RAMTAS routine, part of the RESET sequence, calls
MEMBOT to initialize these locations to 7168/$1C00. However, the
value here is not used by any other system routine,
so changing this value will not affect system operation in any
way. This is a change from the Commodore 64, where the
value in the MEMSTR pointer is used to establish the lowest
address available of BASIC. In the 128, the start-of-BASIC
pointer is always initialized to 7169/$lC01, regardless of the
value here.

## 2567-2568 $0A07-$0A08 MEMSIZ <a name="0A07"></a>
### Kernal MEMTOP pointer
This pair of locations holds the default value of the highest
memory address available in block 0 RAM. The value here can
be read or changed using the Kernal MEMTOP routine
[$F763](E000#F763), which has a Kernal jump table entry at 65433/$FF99.
The RAMTAS routine, part of the RESET sequence, calls
MEMTOP to initialize these locations to $FF00. However, the value
here is not used by any other system routine,
so changing this value will not affect the system operation in
any way. This is a change from the Commodore 64, where the
value in the MEMSIZ pointer is used to establish the highest
address available for BASIC variable storage. In the 128, the
top-of-BASIC pointers are always initialized to $FF00,
regardless of the value here.

## 2569-2570 $0A09-$0A0A IRQTMP <a name="0A09"></a>
### Temporary storage for IIRQ vector during tape operations
These locations are used for temporary storage of the address
value in the IIRQ vector at [$0314-$0315](0300#0314) during tape
operations. The tape routines stash the current IIRQ address
here, then substitute the address of the IRQ service routine to
handle the tape operation. Upon completion of the operation,
the original address stored here will be restored to the IIRQ
vector.

Location 2570/$0A0A is also used as a flag to indicate
whether or not a tape IRQ routine is active. That location is
initialized to 0/$00 by the IOINIT routine, part of the RESET
sequence, and will also be reset to that value upon completion
of the tape operation. Thus, a nonzero value in the flag location
indicates that a tape interrupt routine is active.

## 2571 $0A0B CASTON <a name="0A0B"></a>
### CIA #1 control register A log
This location is used to record the status of CIA #1 control
register A (56334/$DCOE) during tape operations.

## 2572 $0A0C <a name="0A0C"></a>
### CIA #1 interrupt control register log
This location is used to record the status of the CIA #1 interrupt
control register (56333/$DC0D) during tape operations.

## 2573 $0A0D <a name="0A0D"></a>
### CIA #1 timer A status log
The CIA #1 control register A log value from 2571/$0A0B is
stored here during certain tape operations to preserve the
timer A status.

## 2574 $0A0E TIMOUT <a name="0A0E"></a>
### IEEE timeout flag
When the VIC-20 was introduced, its Kernal included a jump
table entry (SETTMO, at 65442/$FFA2) to support a proposed
IEEE bus interface. The IEEE bus is the parallel data bus used
by Commodore's original PET /CBM models for communications with peripheral
devices. The interface was never introduced, but the Kernals of all
subsequent Commodore models
have slavishly included the SETTMO jump table entry. In the
128, the SETTMO routine [$F75F](E000#F75F) does nothing more than
store the accumulator contents in this location. This location is
not used by any other 128 routine, and is provided strictly to
maintain Kernal jump table compatibility with previous Commodore models.

## 2575 $0A0F ENABL <a name="0A0F"></a>
### RS-232 activity flag
This location is used during the RS-232 routines to record the
value in the CIA #2 interrupt control register ([$DD0D](DD00#DD0D)).
CIA #2 interrupt requests generate the NMI interrupts that
drive RS-232 transmission and reception. While the CIA #2
interrupts for RS-232 are disabled, this location will be set to
0/$00. When bits are set in the CIA #2 interrupt control register to
enable RS-232 operations, the corresponding bits are
also set in this location. If any of the following bits is set to
%1, the corresponding interrupt is enabled:

|Bit|Interrupt source|RS-232 activity|
|-|-|-|
|0|Timer A|bits being transmitted|
|1|Timer B|bits being received|
|4|FLAG line|waiting for start bit to be received|

This location is initialized to 0/$00 during the IOINIT routine
[$E109](E000#E109), part of the reset and RUN/STOP-RESTORE
sequences.

## 2576 $0A10 M51CTR <a name="0A10"></a>
### RS-232 control register
This location controls some of the operating characteristics of
the RS-232 interface. When a file is opened to device 2, the
first character of the filename is copied here. Although RS-232
communications in the 128 are managed by software, the bits
of this location are defined to simulate the control register of a
6551 UART chip, a hardware device for controlling serial communications.
The bits are used as follows:

**Bits 0-3**: These bits determine the baud rate for both transmission
and reception-the rate (in bits per second) at which bits
will be sent or received. Valid settings are as follows:

|Bits 3-2-1-0|Bit value|Baud rate|
|-|-|-|
|0 0 0 0|0|user defined|
|0 0 0 1|1|50 baud|
|0 0 1 0|2|75 baud|
|0 0 1 1|3|100 baud|
|0 1 0 0|4|134.5 baud|
|0 1 0 1|5|150 baud|
|0 1 1 0|6|300 baud|
|0 1 1 1|7|600 baud|
|1 0 0 0|8|1200 baud|
|1 0 0 1|9|1800 baud|
|1 0 1 0|10|2400 baud|

When the user-defined rate is selected, the baud rate is determined
by the value in locations [$0A12-$0A13](#0A12).
The remaining possible bit patterns, %1011-%1111, result in
invalid baud rates.

**Bit 4**: Unused.

**Bits 5-6**: These bits determine the number of data bits in each
character sent or received (sometimes referred to as the word
size). The total character length will also include a start bit,
possibly a parity bit, and one or more stop bits.

|Bits 6 5|Bit value|Number of data bits|
|-|-|-|
|0 0|0|8 data bits|
|0 1|32|7 data bits|
|1 0|64|6 data bits|
|1 1|96|5 data bits|

**Bit 7**: This bit determines the number of stop bits in each
character. Stop bits are %1 bits added to the end of the character.
They represent the minimum amount of time the communications line will
remain at the low (%1 bit) level before
the next start bit can be sent or received.

|Bit 7|Bit value|Number of stop bits|
|-|-|-|
|0|0|1 stop bit|
|1|128|2 stop bits|

## 2577 $0A11 M51CDR <a name="0A11"></a>
### RS-232 command register
This location controls some of the operating characteristics of
the RS-232 interface. When a file is opened to device 2, the
second character of the filename, if any, is copied here. Although
RS-232 communications in the 128 are managed by
software, the bits of this location are defined to simulate the
command register of a 6551 UART chip, a hardware device for
controlling serial communications. The bits are used as follows:

**Bit 0**: This bit controls the handshaking mode for RS-232
transmission and reception. The RS-232 interface consists of
three primary signal lines-transmitted data, received data,
and ground-plus a number of supplementary control linesdata set ready
(DSR), data terminal ready (DTR), ready to send
(RTS), and clear to send (CTS). The control lines are called
handshaking lines because they allow the sending and receiving units
to exchange signals (handshakes) indicating whether
data is being successfully transmitted and received. The 128's
RS-232 software interface can operate in two different modes:
3-line, where none of the handshaking lines are used, and xline, where
all of the handshaking lines are used. These bits
control the interface mode as follows:

|Bit 0|Interface mode|
|-|-|
|0|3-line interface (no handshaking)|
|1|x-line interface (full handshaking)|

For 3-line mode, the output handshaking lines (DTR and RTS)
will be held at a constant high (+ 5 volts) level. The input
handshaking lines (DSR and CTS) will be ignored.

**Bits 1-3**: Unused.

**Bit 4**: For unknown reasons, Commodore literature continues
to indicate that this bit controls the duplex mode of the RS232
interface. The bit is supposed to select full duplex when
set to %0 or half duplex when set to % 1. However, this bit is
not checked by any RS-232 routine, and its setting has no effect
on the operation of the interface.
Duplex is often confused with local echo. A full-duplex
interface can simultaneously send and receive data, while a
half-duplex interface can send data and receive data, but not
both at the same time. The 128's RS-232 interface always operates
in full-duplex mode. In casual usage, however, duplex is
often used to describe whether or not the system echoes back
the characters it receives. In remote echo mode (incorrectly referred
to as full duplex), the system displays only characters
received from the remote unit (the one being called). The assumption
is that the remote unit will send back an "echo" of
each character it receives from the system. In local echo mode
(incorrectly called half duplex), the system displays the characters it
sends as well as the ones it receives. The assumption in
this case is that the remote unit will not echo the characters it
receives.

**Bits 5-7**: This bit controls the parity generated for transmitted
characters and the parity tested for in received characters. Parity is
a simple method of detecting some errors in data transmission. A parity
bit can be added between the data and stop
bits in the character. The value of the parity bit is selected to
make the total number of % 1 bits in the character (not counting stop
bits) either even or odd. The receiving unit can then
count the number of % 1 bits in the received character to determine if
bits have been garbled in transmission. Parity
checking did not work properly in the original versions of the
Commodore 64 Kernal ROM, but that problem has been corrected in the
128's Kernal (and in the version of 64 Kernal
ROM for the 128's 64 mode). Possible parity selections are as
follows:

|Bits 7 6 5|Parity selection|
|-|-|
|x x 0|parity not used|
|0 0 1|odd parity|
|0 1 1|even parity|
|1 0 1|mark parity|
|1 1 1|space parity|

If bit 5 is %0, no parity bit will be generated in transmitted characters
and the system will expect incoming characters
to have no parity bit. This selection is common when a word
size of eight data bits per character is used. Odd parity means
that a parity bit will be generated for each transmitted character
such that the character will have an odd total number of
%1 bits (not counting the stop bits). When even parity is selected,
the parity bit will be set to make the total number of
%1 bits in the character even. For either even or odd parity,
the number of %1 bits in each character received will be
counted and compared against the parity selection. If the number does
not match the specified parity type, the error will be
indicated by setting bit 0 of the status register location
[$0A14](#0A14) to %1. Mark and space parity are alternate forms of no
parity. When mark parity is selected, the parity bit for each
transmitted character will always be set to %1, and the parity
bit for each received character will be ignored. When space
parity is selected, the transmitted parity bit will always be %0
and the received parity bit will be ignored.

## 2578-2579 $0A12-$0A13 M51AJB <a name="0A12"></a>
### RS-232 baud-rate factor
The value in these locations determines the baud-rate timing
factor. When a file is opened to device 2, the third and fourth
characters of the filename are copied here (if the filename has
that many characters). However, the filename characters are
meaningful only if a user-defined baud rate has been specified -
if bits 0-3 of the first character of the filename (copied
into 2576/$0A10) are %0000. In that case, the value in these
locations specifies the baud rate according to the following
formula:

```
baud rate = clock frequency / (2 * (rate factor + 100))
```

For the standard baud-rate settings, the Kernal RS-232 OPEN
routine copies the proper rate factor into these locations from
tables in Kernal ROM (59472-59491/$E850-$E863 for NTSC
systems or 59492-59511/$E864-$E877 for PAL systems). The
two separate tables are required because the different video
systems use different clock frequencies.
There's rarely a need to specify a custom baud rate, since
the standard settings encompass all standard rates that the 128
can support. (The 128 cannot handle RS-232 communications
faster than 2400 baud, so don't try to specify a faster rate.)
However, should you ever want to do so, the formula for the
rate factor is as follows:

```
rate factor = ((clock frequency / desired baud rate) / 2) - 100
```

The clock-frequency value is 1022730 for NTSC (North American)
systems or 985250 for PAL (European) systems. The low
byte of the resulting factor should be stored in 2578/$0A12
and the high byte in 2579/$0A13.

## 2580 $0A14 RSSTAT <a name="0A14"></a>
### RS-232 status register
Although RS-232 communications in the 128 are managed by
software, the bits of this location are defined to simulate the
status register of a 6551 DART chip, a hardware device for
controlling serial communications.

It is possible to read the value here directly, but this location can
also be read using the Kernal READSS routine
[$F744](E000#F744) if the current device number in location 186/$BA is 2
(for RS-232). The READSS routine also has a Kernal jump table entry
at 65463/$FFB7. From BASIC, the reserved variable
ST will reflect the value in this location as long as the current
device number is 2. This location is initialized to 0/$00 each
time the Kernal OPEN routine is called to open a file to device
2, the RS-232 interface. The value here is also reset to zero
after each call to the READSS routine when device 2 is active,
including each reference to the ST variable in a BASIC program.
Bit 0: This bit is the parity-error indicator. It is used only
when either even or odd parity is selected, and is relevant
only to received characters. The bit is set to %1 whenever a
character is received for which the calculated total of %1 bits
received for the character does not match the specified parity
selection.

**Bit 1**: This bit is the framing-error indicator. The bit is set to
% 1 when a framing error occurs-when no stop bits are found
following the specified number of data and parity bits.

**Bit 2**: This bit is the receiver buffer-overflow indicator. It will
be set to %1 when a character is received after the RS-232 input buffer
at 3072/$0C00 is already full.

**Bit 3**: This bit is the receiver buffer-empty indicator. It will be
set to % 1 whenever there are no characters waiting to be read
from the input buffer. This bit should be tested before each attempt to read characters from the RS-232 interface.

**Bit 4**: This bit is the CTS-missing error indicator. It is used
only when x-line handshaking is selected. The bit will be set
to %1 if the CTS (clear to send) input line drops to a low (0
volts) state while data is being transmitted. When x-line
handshaking is used, the external device connected to the interface
is expected to hold the CTS line at a high (+ 5 volts)
state. If the line goes low, it is taken as an indication that the
external device is not ready to receive data, so transmission is
suspended until CTS goes high.

**Bit 5**: Unused. This bit should always be %0 when read.

**Bit 6**: This bit is the DSR-missing error indicator. It is used
only when x-line handshaking is selected. The bit will be set
to %1 if the DSR (data set ready) signal input line drops to a
low (0 volts) state during either transmission or reception of
characters. When x-line handshaking is used, the external device connected
to the interface is expected to hold the DSR
line high (+5 volts). If the line goes low, it is taken as an indication
that nothing is connected to the interface.

**Bit 7**: This bit is the break indicator. A break occurs when,
during reception of characters, a byte is received consisting of
all %0 bits not followed by stop bits (which are always %1).
In other words, a break occurs if the received data signal line
is held at the %0 bit (+ 5 volt) level for longer than the time
required to receive a character.

## 2581 $0A15 BITNUM <a name="0A15"></a>
### RS-232 bit count
This location will hold the number of bits prior to the parity
and stop bits for each character received or transmitted. The
location is initialized during the RS-232 OPEN routine [$F040](E000#F040)
to the number of data bits (specified in bits 5-6 of 2576/
$0A10) plus 1. For transmission, the value here is copied into
location 180/$B4, the countdown of bits to send. For reception,
the value here is copied into location 168/$A8, the
countdown of bits remaining to be received.

## 2582-2583 $0A16-$0A17 BAUDOF <a name="0A16"></a>
### RS-232 baud-rate timing constant
Commodore's insistence on providing an exact software emulation of the
6551 UART chip leads to some odd software gyrations. The baud-rate
timing factor specified in locations
[$0A12-$0A13](0A12) must be converted back into an absolute timing
value. The Kernal OPEN routine for RS-232 performs the following calculation:

```
timing constant = (rate factor * 2) - 200
```

Given the formula for rate factor, this is equivalent to:

```
timing constant = dock frequency / baud rate
```

This yields the number of system clock cycles required to send
or receive each bit at the specified baud rate. The resulting
value is stored in these locations. When transmission or reception is
initiated, the value here is copied into one of the CIA
#2 timers. This determines the time between the NMI interrupts that
drive the transmission or reception of bits.

## 2584 $0A18 RIDBE <a name="0A18"></a>
### Index to first character in RS-232 input buffer
This location holds the offset from the start of the RS-232 input
buffer to the position where the next character received
will be stored. The input buffer normally begins at location
$0C00. The value here is incremented before each received character
is added to the buffer, unless incrementing
would make the value here equal to the value in location
[$0A19](#$0A19). In that case, a buffer overflow has occurred
(more characters have been received than the buffer can hold),
so bit 2 of the status location ([$0A14](0A14)) is set to %1.

## 2585 $0A19 RIDBS <a name="0A19"></a>
### Index to last character in RS-232 input buffer
This location holds the offset from the start of the RS-232 input
buffer to the position of the next character waiting to be
removed from the buffer. The buffer normally begins at
$0C00. The value here is incremented after each character is
retrieved from the buffer. When the value here equals the
value in location $0A18, all characters have been removed and the buffer
is empty. In this case, bit 3 of the status
location ([$0A14](0A14)) will be set to %1.

## 2586 $0A1A RODBS <a name="0A1A"></a>
### Index to first character in RS-232 output buffer
This location holds the offset from the start of the RS-232 output buffer
to the position of the next character awaiting transmission. The output
buffer normally begins at 3328/$0D00.
The value here is incremented after each character is removed
from the buffer for transmission. When the value here equals
the value in location 2587/$0A1B, all characters awaiting
transmission have been sent and the buffer is empty.

## 2587 $0A1B RODBE <a name="0A1B"></a>
### Index to last character in RS-232 output buffer
This location holds the offset from the start of the RS-232 output buffer
to the position where the next character will be
added to await transmission. The output buffer normally begins at $0D00.
The value here is incremented before
each character is added to the buffer, unless the incrementing
would make the value here equal the value in 2586/$0A1A.

